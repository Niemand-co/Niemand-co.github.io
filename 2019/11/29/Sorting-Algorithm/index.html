
<!DOCTYPE html>
<html lang="zh-Hans" class="loading">
<head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Sorting Algorithm - Niemand</title>
    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="google" content="notranslate" />
    <meta name="keywords" content="Niemand,"> 
    <meta name="description" content="
    

Sorting Algorithem(updating)


冒泡排序(Bubble Sort)
&amp;emsp;&amp;emsp;冒泡排序正如其名，是让乱序的数像泡泡一样一个接一个“冒上来”。,"> 
    <meta name="author" content="Niemand"> 
    <link rel="alternative" href="atom.xml" title="Niemand" type="application/atom+xml"> 
    <link rel="icon" href="/img/favicon.png"> 
    
<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css">

    
<link rel="stylesheet" href="/css/diaspora.css">

	<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <script>
         (adsbygoogle = window.adsbygoogle || []).push({
              google_ad_client: "ca-pub-8691406134231910",
              enable_page_level_ads: true
         });
    </script>
    <script async custom-element="amp-auto-ads"
        src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
    </script>
<meta name="generator" content="Hexo 4.2.1"><link rel="stylesheet" href="\assets\css\APlayer.min.css" class="aplayer-style-marker">
<script src="\assets\js\APlayer.min.js" class="aplayer-script-marker"></script>
<script src="\assets\js\Meting.min.js" class="meting-script-marker"></script>
</head>

<body class="loading">
    <span id="config-title" style="display:none">Niemand</span>
    <div id="loader"></div>
    <div id="single">
    <div id="top" style="display: block;">
    <div class="bar" style="width: 0;"></div>
    <a class="iconfont icon-home image-icon" href="javascript:;" data-url="http://yoursite.com"></a>
    <div title="播放/暂停" class="iconfont icon-play"></div>
    <h3 class="subtitle">Sorting Algorithm</h3>
    <div class="social">
        <div>
            <div class="share">
                <a title="获取二维码" class="iconfont icon-scan" href="javascript:;"></a>
            </div>
            <div id="qr"></div>
        </div>
    </div>
    <div class="scrollbar"></div>
</div>

    <div class="section">
        <div class="article">
    <div class='main'>
        <h1 class="title">Sorting Algorithm</h1>
        <div class="stuff">
            <span>十一月 29, 2019</span>
            
  <ul class="post-tags-list" itemprop="keywords"><li class="post-tags-list-item"><a class="post-tags-list-link" href="/tags/Sorting/" rel="tag">Sorting</a></li></ul>


        </div>
        <div class="content markdown">
            
    <div id="aplayer-fLJSPyju" class="aplayer aplayer-tag-marker meting-tag-marker"
         data-id="3096834640" data-server="netease" data-type="playlist" data-mode="circulation" data-autoplay="false" data-mutex="true" data-listmaxheight="340px" data-preload="auto" data-theme="#555"
    ></div>
<p><hr></p>
<p><head><font size=15 color=#66ccff>Sorting Algorithem(updating)</font><meta name="generator" content="Hexo 4.0.0"><link rel="alternate" href="/atom.xml" title="Niemand" type="application/atom+xml">
</head></p>
<p><hr></p>
<p><head><strong>冒泡排序(Bubble Sort)</strong></head></p>
<p>&emsp;&emsp;冒泡排序正如其名，是让乱序的数像泡泡一样一个接一个“冒上来”。</p>
<p>&emsp;&emsp;该方法设置两层循环（时间复杂度为O(n^2))，外层循环进行(n-1)次迭代，指冒出(n-1)次气泡；内层循环则是一次冒泡的过程。</p>
<strong>代码如下：</strong><br>
<pre>
//从小到大排序
#include&lt;bits/stdc++.h&gt;

using namespace std;
int a[N];//N为数组长度常量

int main(){
    int temp;
    for(int i=0;i&lt;N-1；i++){
        for(int j=0;j&lt;N-1;j++){
            if(a[j]&gt;a[j+1]){
                temp = a[j];
                a[j] = a[j+1];
                a[j+1] = temp;
            }//若左边的数大于有边的数则交换两数，将更大的数不断右移
        }
    }
    return 0;
}
</pre>
<hr>
<font color=pink>Next</font>
<hr>
<head><strong>快速排序(Quicksort)</strong></head>
<p>&emsp;&emsp;快速排序是利用递归的一种排序。</p>
<p>&emsp;&emsp;首先在一组数列中取一个key值(将它赋值给一个temp，因为这个值本身也要参加排序，我自己写的时候犯蠢了，让这个值固定不动了)，然后在数列左右两边分别向中间遍历，并在必要时进行交换，使得比key值小的数都在左边，比key值大的数都在右边，而两边交汇处则正是key值应该在的地方，而由于在下面的代码中，会控制<font color=red>原key值位置不变</font>(即开头)，这时将key值插入(与交汇位置的值交换)。</p>
<p>&emsp;&emsp;这一通操作后,key值得绝对位置确定了。而key值两边的值还是乱序的，那么两边现在其实就可以看作两个缩短版的原数列，分别采取同上的操作(即递归中的调用函数本身)，然后不断确定新的key值，而每确定一个，就会在其两边产生更短的乱序数列，知道产生的乱序数列只有一个值的时候，则没有必要再排，递归完成。</p>
<hr>
<strong>代码如下：</strong>
<pre>
#include&lt;bits/stdc++.h>
int a[N]={....};//使用全局变量可以方便不同函数调用

void quickSort(int left,int right ) {
    int i, j,temp,t;
    i = left;
    j = right;
    temp = a[left];
    if (left &gt;= right)return;
    while (i != j) {
        //这两处while循环的"="使得与key值相等的数位置不变
        while (a[j] &gt;= temp&&i&lt;j)
            j- -;
        while (a[i] &lt;= temp&&i&lt;j)
            i++;
        if (i &lt;= j) {
            t = a[i];
            a[i] = a[j];
            a[j] = t;
        }
    }
    a[left] = a[i];
    a[i] = temp;
    //将下一轮排序的首位值传入，在全局数组中确定位置
    quickSort(left, i - 1);
    quickSort(i + 1, right);
}
</pre>
<hr>
<font color=pink>next</font>
<hr>
<head><strong>桶排序(Bucket Sort)、基数排序(Radix Sort)</strong></head>
<p>&emsp;&emsp;桶排序这个名字是个很形象的描述，就是先确定几个用来装数据的“桶”，而这些“桶”管理不同的数据范围，也就是将待排序的一组乱序数据根据自身的大小放入不同的“桶”中，而这些已经表明范围的“桶”已经拥有一定的顺序，或者说确定和分配范围的过程就是一种预排序。这些被大致划分并排序的一组组数据内部在进行排序就可以再重新输出时得到完整排序的数列了。</p>
<p>&emsp;&emsp;在选择“桶”的范围时，我们往往会选择能使数据均匀分布的划分方式。而对于基数排序，他的排序思想和桶排序基本相同，区别就在于基数排序在造“桶”时会选择常用的进制数，如10、2、16等，而这也就使得这种排序更加适用于数据更加集中的乱序数列的排序中。</p>
<p>&emsp;&emsp;在下面的例子中将展示以10为划分范围的基数排序，其实也同样展现了桶排序的实现方法。</p>
<pre>
#include<iostream>
#include<stack>
(#include&lt;bits/stdc++.h>)
#define N ...

using namespace std;

int a[N]={...};//由于这里以10为范围，数组中的数应尽量集中
//c/cpp中桶的实现可以用结构体来进行
struct bucket
{
    stack<int> pos;
    struct bucket *next;
}bucket;

void BucketSort(){
    struct bucket *p;
    int temp;
    for(int i=0;i&lt;N;++i){
        //下面将每个数对应各自的“桶”，以10为划分范围
        for(int j=0;j<(a[i]/10);++j){
            p=p->next;
        }
        //在找到对应的桶后，与之前的数进行比较，保证各个“桶”内也按序排列<br>        (但这里的内部排序实现可能这里写得比较复杂，你可以用你自己觉得ok的方法)
        while(p->pos.top()==NULL||p->pos.top()<=a[i])
            p->pos.push(temp);
        while(p->pos.top()>a[i]){
            p->temp.push(p->pos.top());
            p->pos.pop();
        }
        p->pos.push(a[i]);
        while(p->temp.top()!=NULL){
            p->pos.push(p->temp.top());
            p->temp.pop();
        }
    }
}
int main(){
...//函数调用
}
</pre>
<hr>
<font color=pink>next</font>
<hr>
<head><strong>哈希排序(Hash Sort)</strong></head>
<p>&emsp;&emsp;哈希排序我认为可以算是一种特殊的桶排序，一种划分范围是1的桶排序。</p>
<p>&emsp;&emsp;也正因如此，哈希排序免除了桶内排序的操作，思想上也更为直接，但同时这种方法肯定是不稳定的，而且是一种牺牲空间换时间的方法。但在某些对空间要求并不苛刻的情况下，哈希不失为一种好的排序选择。(哈希虽然可耻，但是有效)</p>
<pre>
#include<iostrem>
#define N 10

using namespace std;

int a[N]={};
void HashSort(){
    int p[100];//创建一个包含待排数列中所有数范围的数组
    for(int i=0;i&lt;N;++i){//在数列中有的数对应的位置做标记
        p[a[i]]++;
    }
}
int main(){
...//调用函数
}
</pre>
<hr>
<font color=pink>next</font>
<hr>
<head><strong>直接插入排序(Insertion Sort)</strong></head>
<p>&emsp;&emsp;插入排序就是在乱序数列中(最左)先取一个初始数，因为只有一个数，所以认为已经排好序(此处以自小至大为例)，而从剩下的依旧乱序的数列依次取出一个在已经排好序的做数列中找到相应的位置，再插入。(就是一般被大家比作理扑克那个)</p>
<pre>
#include<iostream>
#define N ...

using namespace std;

int a[N]={...};
void InsertionSort(){
    int i,j;
    int temp;
    for(i=1;i&lt;N;++i){
        if(a[i]&lt;a[i-1]){
        //若右边的数已经大于左边最后一个数则无需插入
            temp=a[i];
            for(j=i-1;j&gt;=0&&a[j]&gt;temp;j--){
                    a[j+1]=a[j];
            }
            a[j+1]=temp;
        }
    }
}
int main(){
...//调用函数
}
</pre>
<head><strong>分组插入排序(Grouping Insertion Sort)</strong></head>
<p>&emsp;&emsp;</p>
            <!--[if lt IE 9]><script>document.createElement('audio');</script><![endif]-->
            <audio id="audio" loop="1" preload="auto" controls="controls" data-autoplay="false">
                <source type="audio/mpeg" src="">
            </audio>
            
                <ul id="audio-list" style="display:none">
                    
                        
                            <li title='0' data-url='http://link.hhtjim.com/163/1371262339.mp3'></li>
                        
                    
                        
                            <li title='1' data-url='http://link.hhtjim.com/163/1371262339.mp3'></li>
                        
                    
                </ul>
            
        </div>
        
    <div id='gitalk-container' class="comment link"
		data-enable='true'
        data-ae='false'
        data-ci='Iv1.fe2e3b8407f255a8'
        data-cs='8495d4c923056665c789914e42e2355b1056eb9b'
        data-r='Niemand-co.github.io'
        data-o='Niemand-co'
        data-a='Niemand-co'
        data-d='true'
    >查看评论</div>


    </div>
    
        <div class='side'>
				
        </div>
    
</div>


    </div>
</div>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>
<script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body>

<script src="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"></script>


<script src="//lib.baomitu.com/jquery/1.8.3/jquery.min.js"></script>
<script src="/js/plugin.js"></script>
<script src="/js/typed.js"></script>
<script src="/js/diaspora.js"></script>


<link rel="stylesheet" href="/photoswipe/photoswipe.css">
<link rel="stylesheet" href="/photoswipe/default-skin/default-skin.css">


<script src="/photoswipe/photoswipe.min.js"></script>
<script src="/photoswipe/photoswipe-ui-default.min.js"></script>


<!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">
    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>
    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">
        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>
        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">
            <div class="pswp__top-bar">
                <!--  Controls are self-explanatory. Order can be changed. -->
                <div class="pswp__counter"></div>
                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
                <button class="pswp__button pswp__button--share" title="Share"></button>
                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>
                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                      <div class="pswp__preloader__cut">
                        <div class="pswp__preloader__donut"></div>
                      </div>
                    </div>
                </div>
            </div>
            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div> 
            </div>
            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>
            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>
            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>
        </div>
    </div>
</div>



<script type="text/x-mathjax-config">
    MathJax.Hub.Config({"HTML-CSS": { preferredFont: "TeX", availableFonts: ["STIX","TeX"], linebreaks: { automatic:true }, EqnChunk: (MathJax.Hub.Browser.isMobile ? 10 : 50) },
        tex2jax: { inlineMath: [ ["$", "$"], ["\\(","\\)"] ], processEscapes: true, ignoreClass: "tex2jax_ignore|dno",skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']},
        TeX: {  noUndefined: { attributes: { mathcolor: "red", mathbackground: "#FFEEEE", mathsize: "90%" } }, Macros: { href: "{}" } },
        messageStyle: "none"
    });
</script>
<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>

<script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>




</html>
