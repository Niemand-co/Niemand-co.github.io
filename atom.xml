<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Niemand</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-05-10T07:15:17.995Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Niemand</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>DSU on tree</title>
    <link href="http://yoursite.com/2020/05/08/DSU-on-tree/"/>
    <id>http://yoursite.com/2020/05/08/DSU-on-tree/</id>
    <published>2020-05-08T11:05:54.000Z</published>
    <updated>2020-05-10T07:15:17.995Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><center><font size=8 color=66ccff>DSU on tree</font></center><p>前置知识：<a href="https://niemand-co.github.io/2020/05/01/Tree-Chain-Partition/#more" target="_blank" rel="noopener">树链剖分</a></p><p>&emsp;&emsp;终于来到了dsu on tree<del>(为了学这玩意从rmq、lca一直爬到树剖)</del>，我也是才知道dsu其实是指并查集(Disjoint Sets Union)，虽然学完感觉和并查集并没有什么大关系。</p><p>&emsp;&emsp;既然前面提到了树剖，其实这就是这个算法的主体。先来引入一个<a href="https://www.luogu.com.cn/problem/U41492" target="_blank" rel="noopener">例题</a>。这题的大意其实就是给一颗有着各种颜色的树，查询一个节点，要求得出该节点为根的子树上有多少种颜色。这种问题显然不同于之前树剖的立体可以利用线段树进行区间整体的维护，这种要求种类数量的问题需要完整的搜索才能得出。也就是每问一个点就需要进行一次dfs遍历整棵子树，当然这种时间复杂度肯定是不允许的，不然也没必要正这种算法。</p><p>&emsp;&emsp;于是肯定有人会想，将每个节点的答案保存，再逐渐回溯上升推出答案，将节点的答案相加什么的<del>(整的跟dp一样)</del>。然而用一个节点举例，如果这个点有两个子树，这两颗子树若存在相同的颜色，那么相加就会导致重复计算，或者想要分别整一个hash数组，那么内存肯定会炸。既不能标记，也不能直接计算，那还是只能暴力。所以dsu on tree其实就是一种暴力算法，那么和所问之点全部深搜一边有什么不同呢？</p><p>&emsp;&emsp;上面说了，树剖是主体。那么树剖让我们得到了什么？每个节点的重儿子，了解树剖的都知道，重儿子代表了他是父节点下面最大子树的根节点，对二叉树来说，相当于对于同一层次的另一节点，他的信息量占了起码一半。那么我们就可以选择性得保留信息，比如我只记录重儿子下属子树的颜色个数，对于轻儿子我们还是老实地dfs一遍，这就最大化地减少了搜索的量。</p><p>&emsp;&emsp;那么针对这一道题，我们的解法就是在树剖的第二个dfs中直接记录每个点的答案。经过第一次的dfs，我们得到了每个节点的重儿子son，然后在第二次dfs中，优先遍历轻儿子。然后利用hash数组统计颜色种类数，只利用一个变量ans记录当前已经纳入统计的颜色种类数量，然后将这个答案记录到当前所求点。因为这是轻儿子，所以在记录完后，重新搜索子树将讲所有统计内的颜色逐个删去，并且更新变量ans。然后ans就没有记录轻儿子及其子树的数据了。接下来访问重儿子，同时标明保留记录，并且对这个重儿子节点进行标记。结束了对重儿子的访问，接下来是当前节点的计算，首先将本节点的颜色纳入记录，然后遍历他的子节点(其实就是第三个dfs)，但是此处的遍历直接跳过重儿子son，因为son及其下面所有的节点都已经保留在ans中了，这就相当于在dfs时省去了一大株子树，而这也就是这个算法的优化点。</p><p>代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 100010</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">int</span> to,next;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">&#125;edge[N];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> son[N],siz[N],top[N],fa[N],head[N];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> cnt=<span class="number">0</span>,ans=<span class="number">0</span>,vis[N],out[N];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> c[N];<span class="comment">//这是用来记录某种颜色的数量的</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[N];<span class="comment">//这是用来记录节点的颜色的</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v)</span></span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">        edge[++cnt].to=v;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">        edge[cnt].next=head[u];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">        head[u]=cnt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">&#125;<span class="comment">//链式前向星</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">dfs1</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v)</span></span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line">        fa[v]=u;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line">        siz[v]=<span class="number">1</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=head[v];i;i=edge[i].next)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">25</span></pre></td><td class="code"><pre><span class="line">                <span class="keyword">int</span> t=edge[i].to;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">26</span></pre></td><td class="code"><pre><span class="line">                <span class="keyword">if</span>(t==fa[v])<span class="keyword">continue</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">27</span></pre></td><td class="code"><pre><span class="line">                dfs1(v,t);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">28</span></pre></td><td class="code"><pre><span class="line">                siz[v]+=siz[t];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">29</span></pre></td><td class="code"><pre><span class="line">                <span class="keyword">if</span>(!son[v]||siz[t]&gt;siz[son[v]])son[v]=t;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">30</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">31</span></pre></td><td class="code"><pre><span class="line">&#125;<span class="comment">//遍历后得到重儿子</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">32</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">33</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">cal</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v,<span class="keyword">int</span> boo)</span></span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">34</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">if</span>(boo)&#123;<span class="comment">//这个boo是用来标记本次计算是来记录节点及其子树的还是删去记录的</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">35</span></pre></td><td class="code"><pre><span class="line">                <span class="keyword">if</span>(!c[a[v]])++ans;<span class="comment">//加上当前节点前，这种颜色个数为0那么种类数加一</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">36</span></pre></td><td class="code"><pre><span class="line">                ++c[a[v]];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">37</span></pre></td><td class="code"><pre><span class="line">        &#125;<span class="keyword">else</span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">38</span></pre></td><td class="code"><pre><span class="line">                --c[a[v]];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">39</span></pre></td><td class="code"><pre><span class="line">                <span class="keyword">if</span>(!c[a[v]])--ans;<span class="comment">//若减去当前节点后，这种颜色的个数为0那么种类数减一</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">40</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">41</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=head[v];i;i=edge[i].next)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">42</span></pre></td><td class="code"><pre><span class="line">                <span class="keyword">int</span> t=edge[i].to;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">43</span></pre></td><td class="code"><pre><span class="line">                <span class="keyword">if</span>(t==u||vis[t])<span class="keyword">continue</span>;<span class="comment">//跳过了重儿子及其子树，关键优化</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">44</span></pre></td><td class="code"><pre><span class="line">                cal(v,t,boo);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">45</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">46</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">47</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">48</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v,<span class="keyword">int</span> boo)</span></span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">49</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=head[v];i;i=edge[i].next)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">50</span></pre></td><td class="code"><pre><span class="line">                <span class="keyword">int</span> t=edge[i].to;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">51</span></pre></td><td class="code"><pre><span class="line">                <span class="keyword">if</span>(t==u||t==son[v])<span class="keyword">continue</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">52</span></pre></td><td class="code"><pre><span class="line">                dfs2(v,t,<span class="number">0</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">53</span></pre></td><td class="code"><pre><span class="line">        &#125;<span class="comment">//此处先遍历轻儿子，因为要保留重儿子</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">54</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">if</span>(son[v])&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">55</span></pre></td><td class="code"><pre><span class="line">                dfs2(v,son[v],<span class="number">1</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">56</span></pre></td><td class="code"><pre><span class="line">                vis[son[v]]=<span class="number">1</span>;<span class="comment">//对于当前节点的重儿子进行标记，使其在本节点的计算时能够被跳过</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">57</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">58</span></pre></td><td class="code"><pre><span class="line">        cal(u,v,<span class="number">1</span>);<span class="comment">//本节点计算</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">59</span></pre></td><td class="code"><pre><span class="line">        vis[son[v]]=<span class="number">0</span>;<span class="comment">//换节点后需要重置重儿子标记</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">60</span></pre></td><td class="code"><pre><span class="line">        out[v]=ans;<span class="comment">//记录当前节点的答案，也就是他的子树中颜色种类数</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">61</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">if</span>(!boo)cal(u,v,<span class="number">0</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">62</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">63</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">64</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">65</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">int</span> n;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">66</span></pre></td><td class="code"><pre><span class="line">        <span class="built_in">cin</span>&gt;&gt;n;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">67</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n<span class="number">-1</span>;++i)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">68</span></pre></td><td class="code"><pre><span class="line">                <span class="keyword">int</span> x,y;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">69</span></pre></td><td class="code"><pre><span class="line">                <span class="built_in">cin</span>&gt;&gt;x&gt;&gt;y;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">70</span></pre></td><td class="code"><pre><span class="line">                addEdge(x,y);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">71</span></pre></td><td class="code"><pre><span class="line">                addEdge(y,x);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">72</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">73</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">74</span></pre></td><td class="code"><pre><span class="line">                <span class="built_in">cin</span>&gt;&gt;a[i];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">75</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">76</span></pre></td><td class="code"><pre><span class="line">        dfs1(<span class="number">1</span>,<span class="number">1</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">77</span></pre></td><td class="code"><pre><span class="line">        dfs2(<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">78</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">int</span> q;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">79</span></pre></td><td class="code"><pre><span class="line">        <span class="built_in">cin</span>&gt;&gt;q;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">80</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> p,i=<span class="number">0</span>;i&lt;q;++i)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">81</span></pre></td><td class="code"><pre><span class="line">                <span class="built_in">cin</span>&gt;&gt;p;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">82</span></pre></td><td class="code"><pre><span class="line">                <span class="built_in">cout</span>&lt;&lt;out[p]&lt;&lt;<span class="string">'\n'</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">83</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">84</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">85</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><p><del>然而我这代码在oj上炸内存了QAQ</del>，看个思路就好。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="Algorithm" scheme="http://yoursite.com/categories/Algorithm/"/>
    
    
      <category term="Algorithm" scheme="http://yoursite.com/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>Tree Chain Partition</title>
    <link href="http://yoursite.com/2020/05/01/Tree-Chain-Partition/"/>
    <id>http://yoursite.com/2020/05/01/Tree-Chain-Partition/</id>
    <published>2020-04-30T16:00:00.000Z</published>
    <updated>2020-05-03T11:47:39.791Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><center><font size=8 color=66ccff>Tree Chain Partition</font></center><p>前置知识：<a href="https://niemand-co.github.io/2020/03/27/LCA/" target="_blank" rel="noopener">LCA</a>、<a href="https://niemand-co.github.io/2020/04/30/Segment-Tree/" target="_blank" rel="noopener">线段树</a></p><p>&emsp;&emsp;树链剖分(Tree Chain Partition)这是一种将一棵树进行分解成链来进行维护的算法，分为重链剖分和长链剖分。</p><hr><font size=5 color=ccccff>重链剖分</font><p>&emsp;&emsp;重链剖分就是按照子树大小进行分解。首先找到每个父节点中，下接子树最大的子节点，也就是重儿子，进行标记，然后将相邻的标记点连接成链，就是重链了。</p><p>&emsp;&emsp;先利用树状数组建立一棵树：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span>&#123;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">int</span> to,from,next;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">&#125;edge[N];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> head[N];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> fa[N];<span class="comment">//父节点</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> siz[N];<span class="comment">//某个节点下的子树大小</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> son[N];<span class="comment">//某个父节点的重儿子</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> d[N];<span class="comment">//节点深度</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> cnt=<span class="number">0</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">    edge[cnt].from=x;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">    edge[cnt].to=y;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">    edge[cnt].next=head[x];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">    head[x]=cnt++;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><p>&emsp;&emsp;在完成建树后，可以开始树剖了。树剖的思想其实还是dfs，通过两次dfs遍历就可以得到重链。</p><p>&emsp;&emsp;第一次dfs时，先记录根节点size为1，然后遍历他的子节点，对于每个子节点进行相同的操作。在到达子节点开始回溯时，将每个子节点的size加到对应父节点的size中，因为这个size代表的是一个节点的子树的大小。若某一父节点的子节点完成操作，则将这一父节点与爷爷节点已经记录的son的size进行比较，若大于已经记录的size，则进行一次更新，将新的父节点记录为son。经过一轮横向迭代，就可以得到这一迭代父节点的重儿子。在所有节点的重儿子都已经找到则完成第一次dfs。</p><p>&emsp;&emsp;第二次dfs时，从根节点开始，将这个节点的top记录为自己(top代表一条重链的顶端节点)，然后优先向son搜索，将son的top也记录为上一节点的top。然后再遍历其它轻儿子，对于每个轻儿子他们也有自己的重儿子，所以也是进行相同操作。</p><p>代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs1</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v,<span class="keyword">int</span> depth)</span></span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    fa[v]=u;<span class="comment">//标记父节点</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    d[V]=depth;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    siz[v]=<span class="number">1</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=head[v];i;i=edge[i].next)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">int</span> t=edge[i].to;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">if</span>(t==u)<span class="keyword">continue</span>;<span class="comment">//子节点不能个和父节点重合</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">        dfs1(v,t,depth+<span class="number">1</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">        siz[v]+=siz[t];<span class="comment">//获取子树大小</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">if</span>(siz[v]&gt;siz[son[v]])son[v]=t;<span class="comment">//通过比较获取重儿子</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> f)</span></span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">    top[n]=f;<span class="comment">//记录一条重链的第一个节点</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">if</span>(!son[n])<span class="keyword">return</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">    dfs2(son[n],f);<span class="comment">//优先搜索重儿子传递同一重链的头节点</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=head[n];i;i=edge[i].next)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">int</span> v=edge[n].to;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">if</span>(v==son[n]||v=fa[n])<span class="keyword">continue</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">        dfs2(v,v);<span class="comment">//搜索轻儿子，该重链的头结点就是自己</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><p>&emsp;&emsp;这只是重链剖分的基本操作，以得到重链，下面是一道重链剖分和线段树的结合模板题。</p><p><a href="https://www.luogu.com.cn/problem/P3384" target="_blank" rel="noopener">原题P3384</a></p><p>&emsp;&emsp;先来考虑前两种操作，这两种都是类似中序遍历的操作顺序，这就需要lca的思想，而这里实际用到的则是重链。利用重链上的节点所记录的top进行快速跳转，使得所求的两点移动到同一条重链上然后再进行同一条链上的操作。</p><p>&emsp;&emsp;为什么要在同一条重链上呢？这是因为在重链生成的dfs2中，会对节点进行编号，而我们都知道的，在第二次深搜中我们总是优先进入重儿子，因此一条重链上的点编号是连续的。因此我们对应的建立<font color=66ccff>线段树</font>，因为线段树上的操作对于连续的区间十分有利，因此我们将编号好的的树映射到线段树上,于是同一条重链上的节点就会在线段树的叶节点上呈现为连续的分布。</p><p>&emsp;&emsp;那么我们需要修改的就是第二次深搜和线段树的建树过程。代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> f)</span></span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    top[n]=f;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    id[n]=++cnt;<span class="comment">//记录每个的编号</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    rank[cnt]=n;<span class="comment">//将节点按照顺序放入数组中，在建立线段树时利用这个进行叶节点赋值</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">if</span>(!son[n])<span class="keyword">return</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    dfs2(son[n],f);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=head[n];i;i=edge[i].next)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">int</span> v=edge[n].to;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">if</span>(v==son[n]||v=fa[n])<span class="keyword">continue</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">        dfs2(v,v);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">create</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">    nide[n].l=l;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">    node[n].r=r;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">if</span>(l==r)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">        node[n].sum=rank[l];<span class="comment">//利用顺序数组进行赋值，当区间左右边界相同时，边界也就是编号</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">return</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line">    create(n&lt;&lt;<span class="number">1</span>,l,mid);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line">    create(n&lt;&lt;<span class="number">1</span>+<span class="number">1</span>,mid+<span class="number">1</span>,r);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line">    node[n].sum=node[n&lt;&lt;<span class="number">1</span>].sum+node[n&lt;&lt;<span class="number">1</span>+<span class="number">1</span>].sum;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">25</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><p>&emsp;&emsp;到此也就完成了树到线段树的映射。那么接下来怎么进行中序求和以及修改呢？我们目前已经有了下面的线段树的求和与修改操作(如果不懂上面有链接)：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">int</span> ans=<span class="number">0</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">if</span>(node[n].l&gt;=l&amp;&amp;node[n].r&lt;=r)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">return</span> node[n].sum;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    pushDown(n);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">int</span> mid=(node[n].l+node[n].r)&gt;&gt;<span class="number">1</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">if</span>(l&lt;=mid)ans+=search(n&lt;&lt;<span class="number">1</span>,l,mid);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">if</span>(r&gt;mid)ans+=search(n&lt;&lt;<span class="number">1</span>+<span class="number">1</span>,mid+<span class="number">1</span>,r);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">return</span> ans;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> k,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">if</span>(node[n].l&gt;=l&amp;&amp;node[n].r&lt;=r)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">        node[n].sum+=k*(node[n].r-node[n].l+<span class="number">1</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">        node[n].lz=k;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">return</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">    pushDown(n);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">int</span> mid=(node[n].l+node[n].r)&gt;&gt;<span class="number">1</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">if</span>(l&lt;=mid)add(n&lt;&lt;<span class="number">1</span>,k,l,mid);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">if</span>(r&gt;mid)add(n&lt;&lt;<span class="number">1</span>+<span class="number">1</span>,k,mid+<span class="number">1</span>,r);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line">    node[n].sum=node[n&lt;&lt;<span class="number">1</span>].sum+node[n&lt;&lt;<span class="number">1</span>+<span class="number">1</span>].sum;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><p>&emsp;&emsp;那么正如上面所说我们的思想与lca无异(倍增的那种)，我们首先有两个所求的点，我们先对他们的top进行判断(因为每次跃迁都是直达top节点的父节点，因此可能会跳过头)，找到top节点更低的那个进行首次跃迁(当然如果top相同的话那就直接进入下一环节)，直接将节点移动到top的父节点，当然同时要对原节点和top节点之间进行一次线段树的求和或者修改操作。跃迁之后再次进行相同的判断，知道两个所求的节点的top相同，那么此时两点处于同一重链上，可以直接用线段树的操作进行最后的计算。代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TreeSum</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">int</span> ans=<span class="number">0</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">while</span>(top[x]!=top[y])&#123;<span class="comment">//直到两点处于同一条重链上</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">if</span>(d[top[x]]&lt;d[top[y]])swap(x,y);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">        ans=(ans+sum(<span class="number">1</span>,id[top[x]],id[x]))%mod;<span class="comment">//同一重链在线段树上是连续区间所以直接进行线段树操作，同时将要跳过的这段和先记录</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">        x=fa[top[x]];<span class="comment">//进行跃迁</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">if</span>(d[x]&gt;d[y])swap(x,y);<span class="comment">//重链上按照从上到下的顺序在线段树叶节点上从左到右排布</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">    ans=(ans+sum(<span class="number">1</span>,id[x],id[y]))%mod;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TreeAdd</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> k)</span></span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">while</span>(top[x]!=top[y])&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">if</span>(d[top[x]]&lt;d[top[y]])swap(x,y);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">        add(<span class="number">1</span>,id[top[x]],id[x]);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">        x=fa[top[x]];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">if</span>(d[x]&gt;d[y])swap(x,y);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">    add(<span class="number">1</span>,x,y);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="Algorithm" scheme="http://yoursite.com/categories/Algorithm/"/>
    
    
      <category term="Algorithm" scheme="http://yoursite.com/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>Segment Tree</title>
    <link href="http://yoursite.com/2020/04/30/Segment-Tree/"/>
    <id>http://yoursite.com/2020/04/30/Segment-Tree/</id>
    <published>2020-04-29T16:00:00.000Z</published>
    <updated>2020-04-30T08:37:43.304Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><center><font size=10 color=66ccff>Segment Tree</font></center><p>&emsp;&emsp;线段树(Segment Tree)是个用空间换时间的数据结构,可以用于区间的染色、查询、求和等操作。线段树从名字就可以看出是对于一个一维线段的操作，将原本逐个遍历的操作进行优化。</p><p>&emsp;&emsp;首先，线段树的构成其实是一种二叉树，树的根节点是一整个区间，而叶子则是区间的最小单位，每个父节点是两个子节点的合并区间，并且两个子节点区间是对半分的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">    (1,4)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">   &#x2F;     \</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"> (1,2)  (3,4)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"> &#x2F;  |    |  \</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">1   2    3   4</span></pre></td></tr></table></figure><p>&emsp;&emsp;以[1,4]这个区间为例大概是这种感觉。但这些只是节点的编号，并非权值，每个 父节点的权值就是子节点的权值相加，因此可以通过这一点进行建树和求和优化。</p><p>&emsp;&emsp;因此利用上述线段树的本质构成，可以进行线段树的建立，一维的数组分布在树的叶子上，而父节点是子节点的和，那么我们必然要先创建叶子，此时就需要按照dfs序。对于一个非叶节点先创建他的两个子节点，然后在回溯的时候利用求和得到该节点。代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">int</span> l,r,lz,sum;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">&#125;node[N];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">create</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    node[n].l=l;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">    node[n].r=r;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">if</span>(l==r)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">        node[n].sum=a[cnt++];<span class="comment">//a数组是所求的区间数组，按序赋值给叶节点</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">return</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">    create(n&lt;&lt;<span class="number">1</span>,l,mid);<span class="comment">//根据二叉树本身的规律就会发现以横向顺序来看，父节点是第n个，那么他的两个子节点分别是第2n和2n+1个</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">    create(n&lt;&lt;<span class="number">1</span>+<span class="number">1</span>,mid+<span class="number">1</span>,r);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">    node[n].sum+=(node[n&lt;&lt;<span class="number">1</span>].sum+node[n&lt;&lt;<span class="number">1</span>+<span class="number">1</span>].sum);<span class="comment">//回溯时构成中间的节点</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><p>&emsp;&emsp;接下来是线段树的几种操作。首先是查询操作，其实也就是求和，查询一段内包含区间的总权值。</p><p>&emsp;&emsp;求一段给定区间的和首先从区间最大的根节点开始，在遇到每一个节点时进行判断，这个节点的左边界和右边界是否全部包含在给定区间内。如果是，那么ans加上这个节点的权值，然后回溯，不需要继续搜索他的子树；如果不是，那么在此判断，该节点的两个子节点是否与给定区间有交集，如果是则进行搜索，并重复上述操作进行递归。</p><p>&emsp;&emsp;此处搜索子节点的判断：取得父节点的区间中值，如果给定区间的左边界小于等于中值，则左子节点有交集，若给定区间的右边界大于中值，则右子节点有交集。代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">int</span> ans=<span class="number">0</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">if</span>(node[n].l&gt;=l&amp;&amp;node[n].r&lt;=r)&#123;<span class="comment">//判断该节点是否完全包含于所求区间</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">return</span> node[n].sum;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">int</span> mid=(node[n].l+node[n].r)&gt;&gt;<span class="number">1</span>;<span class="comment">//取得区间中值</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">if</span>(l&lt;=mid)ans+=search(n&lt;&lt;<span class="number">1</span>,l,mid);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">if</span>(r&gt;mid)ans+=search(n&lt;&lt;<span class="number">1</span>+<span class="number">1</span>,mid+<span class="number">1</span>,r);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">return</span> ans;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><p>&emsp;&emsp;接下来是修改操作，就是使得区间内的每一个单点权值加上某一个数。</p><p>&emsp;&emsp;这种操作其实还是一样的道理，从根节点开始判断，如果遇到一个节点完全包含于给定区间，那么直接对这个节点进行加权。当然，加权是针对单个点的，那么就需要知道这个节点包含多少最小点，那么这个节点的加权值就应该是给定值与节点区间长度的乘积。如果遇到非全包含的节点，则需要做出同上面查询操作一样的左右节点是否搜索判断。代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> k,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">if</span>(node[n].l&gt;=l&amp;&amp;node[n].r&lt;=r)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">        node[n].sum+=k*(node[n].r-node[n].l+<span class="number">1</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">return</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">int</span> mid=(node[n].l+node[n].r)&gt;&gt;<span class="number">1</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">if</span>(l&lt;=mid)add(n&lt;&lt;<span class="number">1</span>,k,l,mid);<span class="comment">//或者if(node[n].r&gt;=l)</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">if</span>(r&gt;mid)add(n&lt;&lt;<span class="number">1</span>+<span class="number">1</span>,k,mid+<span class="number">1</span>,r);<span class="comment">//或者if(node[n].l&lt;=r)</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><p>&emsp;&emsp;以上是两种基本操作，但是问题出现了，如果对于一个区间先进行修改操作，然后对于另外一个相交区间进行查询操作会怎么样？例如，我先对[1,3]中的每一个点进行+2修改，然后查询[2,4]的总权值。在前者操作中，由以上算法可知，我们实际上只对叶节点3进行了+2修改以及对(1,2)节点进行了+4修改。而在后者操作中，我们查询时求和的权值来源于叶节点2和(3,4)节点，然而这两个点并没有得到修改，这就造成了错误。那么如何进行优化呢？</p><p>&emsp;&emsp;首先我们需要一个pushDown函数，其实在开头定义的node结构体中一直有个变量没有使用过，那就是lz(lazetag)。这个变量的作用就是记录对于该节点的修改，从而在下次查询该节点的子节点而非该节点本身时将lz的值传递下去，修改子节点从而查询得到正确的值。pushDown的代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushDown</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">if</span>(!node[n].lz)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">        <span class="comment">//继续向下传递lz标记，因为查询的节点可能再更下面</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">        node[n&lt;&lt;<span class="number">1</span>].lz=node[n].lz;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">        node[n&lt;&lt;<span class="number">1</span>+<span class="number">1</span>].lz=node[n].lz;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">        <span class="comment">//下面需要将每个子节点的权值也相应加权，保证查询正确</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">        node[n&lt;&lt;<span class="number">1</span>].sum+=node[n].lz*(node[n&lt;&lt;<span class="number">1</span>].r-node[n&lt;&lt;<span class="number">1</span>].l+<span class="number">1</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">        node[n&lt;&lt;<span class="number">1</span>+<span class="number">1</span>].sum+=node[n].lz*(node[n&lt;&lt;<span class="number">1</span>+<span class="number">1</span>].r-node[n&lt;&lt;<span class="number">1</span>+<span class="number">1</span>].l+<span class="number">1</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">    node[n].lz=<span class="number">0</span>;<span class="comment">//父节点lz标记归零防止重复</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><p>&emsp;&emsp;这就完成了函数的准备，还需要解决一个问题(3,4)节点的查询没有得到来自节点3的修改。这个其实自要在修改时的递归回溯中重新利用建树时的子节点求和操作就行了。</p><p>代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">int</span> ans=<span class="number">0</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">if</span>(node[n].l&gt;=l&amp;&amp;node[n].r&lt;=r)&#123;<span class="comment">//判断该节点是否完全包含于所求区间</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">return</span> node[n].sum;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    pushDown(n);<span class="comment">//在向下查询前进行标记下推操作，防止出错</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">int</span> mid=(node[n].l+node[n].r)&gt;&gt;<span class="number">1</span>;<span class="comment">//取得区间中值</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">if</span>(l&lt;=mid)ans+=search(n&lt;&lt;<span class="number">1</span>,l,mid);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">if</span>(r&gt;mid)ans+=search(n&lt;&lt;<span class="number">1</span>+<span class="number">1</span>,mid+<span class="number">1</span>,r);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">return</span> ans;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> k,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">if</span>(node[n].l&gt;=l&amp;&amp;node[n].r&lt;=r)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">        node[n].sum+=k*(node[n].r-node[n].l+<span class="number">1</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">        node[n].lz=k;<span class="comment">//标记lz变量</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">return</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">    pushDown(n);<span class="comment">//修改操作中使用这个函数其实在第一次修改中看起来没有用，但如果进行多次修改就会用上</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">int</span> mid=(node[n].l+node[n].r)&gt;&gt;<span class="number">1</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">if</span>(l&lt;=mid)add(n&lt;&lt;<span class="number">1</span>,k,l,mid);<span class="comment">//或者if(node[n].r&gt;=l)</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">if</span>(r&gt;mid)add(n&lt;&lt;<span class="number">1</span>+<span class="number">1</span>,k,mid+<span class="number">1</span>,r);<span class="comment">//或者if(node[n].l&lt;=r)</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line">    node[n].sum=node[n&lt;&lt;<span class="number">1</span>].sum+node[n&lt;&lt;<span class="number">1</span>+<span class="number">1</span>].sum;<span class="comment">//回溯求和更新中间节点</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="Algorithm" scheme="http://yoursite.com/categories/Algorithm/"/>
    
    
      <category term="Algorithm" scheme="http://yoursite.com/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>Two Pointers</title>
    <link href="http://yoursite.com/2020/04/11/Two-Pointers/"/>
    <id>http://yoursite.com/2020/04/11/Two-Pointers/</id>
    <published>2020-04-10T16:00:00.000Z</published>
    <updated>2020-04-11T13:10:08.354Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><font size=10 color=66ccff>Tow Pointers</font><p>&emsp;&emsp;尺取法(Tow Pointers)是一种比较适用于一维数据列的平凡算法。这种算法的基本原理就是利用两个标识在同一段数据上独立移动，利用两点之间的长度变化解决得到不同的取值情况从而解决各种问题。</p><p>&emsp;&emsp;例如在一维数列中寻找一段最短的一串连续数列使其总和大于一个数S。首先将两个pointer(以下称为p)都置于数组开头，先向右移动右p，并且不算算出左右p之间的数值总和，并且与S比较，如果小于S则继续移动，如果大于S则停止移动右p转而向右移动左p，使得两p之间的尺度减小，但这同时也会使得数值总和减小，因此在总和减小至小于S前的最后一个左p的位置到右p的位置就是这一段的最小连续序列。</p><p>&emsp;&emsp;而当总和小于S后，继续回来移动右p，直到再次大于S并且重复操作，这样就可以得到一段有一段的最小序列，最后从中找到全场的最小连续子序列。</p><p>代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">int</span> n,s,a[<span class="number">100</span>];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">int</span> l=<span class="number">0</span>,r=<span class="number">0</span>,sum=<span class="number">0</span>,ans=<span class="number">0xffffff</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;s;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">        <span class="built_in">cin</span>&gt;&gt;a[i];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">while</span>(r&lt;n&amp;&amp;sum&lt;s)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">            sum+=a[r++];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">if</span>(sum&lt;s)<span class="keyword">break</span>;<span class="comment">//此处的判断旨在判断上面的循环是否是因为右p到头而跳出的，如果是那么遍历就到此结束</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">        ans=ans&lt;(r-l+<span class="number">1</span>)?ans:(r-l+<span class="number">1</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">        sum-=a[l++];<span class="comment">//这里减去左p的值，进入下一次循环时会判断sum和s的大小，如果大于则左p还可以继续右移，反之则回到右p</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">    <span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><p>&emsp;&emsp;下面给出另一道例题：</p><p>&ensp;&ensp;Today is Jaime’s birthday and, to celebrate, his friends ordered a cake decorated with eggfruits and persimmons. When the cake arrived, to their surprise, they noticed that the bakery didn’t use equal amounts of eggfruits and persimmons, but just randomly distributed the fruits over the cake’s border instead.</p><p>&ensp;&ensp;Jaime eats persimmons every day, so he was eager to try some eggfruit on his birthday. However, as he doesn’t want to eat too much, his cake slice should be decorated with at most S fruits. Since Jaime doesn’t like when a fruit is cut into parts, each fruit should either be entirely in his slice or be left in the rest of the cake. The problem is, with the fruits distributed in such a chaotic order, his friends are having trouble cutting a suitable slice for him.</p><p>&ensp;&ensp;Jaime is about to complain that his friends are taking too long to cut his slice, but in order to do so, he needs to know how many different slices with at least one eggfruit and containing at most S fruits there are. A slice is defined just based on the set of fruits it contains. As Jaime is quite focused on details, he is able to distinguish any two fruits, even if both fruits are of the same type. Hence, two slices are considered different when they do not contain exactly the same set of fruits. The following picture shows a possible cake, as well as the six different slices with at most S = 2 fruits that can be cut from it.</p><p>Input:<br>The first line contains a circular string B (3 ≤ |B| ≤ 1e5) describing the border of the cake. Each character of B is either the uppercase letter “E” or the uppercase letter “P”, indicating respectively that there’s an eggfruit or a persimmon at the border of the cake. The second line contains an integer S (1 ≤ S &lt; |B|) representing the maximum number of fruits that a slice can contain.</p><p>Output:<br>Output a single line with an integer indicating the number of different slices with at most S fruits ,and at least one eggfruit.</p><p>Input:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">PEPEP</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">2</span></pre></td></tr></table></figure><p>Output:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">6</span></pre></td></tr></table></figure><p>Input:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">EPE</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">1</span></pre></td></tr></table></figure><p>Output:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">2</span></pre></td></tr></table></figure><p>Input:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">EPEP</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">2</span></pre></td></tr></table></figure><p>Output:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">4</span></pre></td></tr></table></figure><p>&emsp;&emsp;题意：从给定的由E、P组成的字符串(左右相接循环)中找到所有的至少包含一个E的不重复子序列，该子序列长度最大为s。</p><p>&emsp;&emsp;这道题不同于上一题，并不是对于一段数的加减，而是一个字符串的序列组合，因此在一开始困扰我很久的就是尺取法的精髓在于移动一次pointer时可以通过这一点的数据就直接判断子序列的变化，并且得到反馈。而这种字符串序列的问题该如何只通过改变一个字符来及时判断是否是新的不重复的序列。</p><p>&emsp;&emsp;这里的关键点我还是参照了别人的方法，那就是先将一个E作为一个子序列最左端的E，然后左p从数列最左端或者上一个E的右边开始逐步右移，计左p到这个E(也就是右p)的距离为x(也就是有E左边有x个P)，这x个P是全部包含在子序列中，此时子序列已经占用了x+1的长度，剩余的可占用的长度为s-x-1，在接下来(s-x-1)个字符可以有(s-x-1)中取法，就相当于得到了(s-x-1)个不同的子序列。接下来再将左p右移一步，得到左边为x-1的长度，再重复操作。以此类推，每个E都进行这种操作就可以得到所有的非重复子序列了。</p><p>代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    <span class="built_in">string</span> a;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">int</span> s,ans=<span class="number">0</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">int</span> l=<span class="number">0</span>,r=<span class="number">0</span>,flag=<span class="number">0</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    <span class="built_in">cin</span>&gt;&gt;a;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    <span class="built_in">cin</span>&gt;&gt;s;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">int</span> n=a.size();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">while</span>(l&lt;n)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">while</span>(r&lt;n&amp;&amp;flag==<span class="number">0</span>)<span class="keyword">if</span>(a[r++]==<span class="string">'E'</span>)flag++;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">if</span>(flag==<span class="number">0</span>)<span class="keyword">break</span>;<span class="comment">//如果右p到头且不是E则说明已经结束</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">        ans+=<span class="number">0</span>&gt;s-(r-l<span class="number">-1</span>)?<span class="number">0</span>:s-(r-l<span class="number">-1</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">if</span>(a[l++]==<span class="string">'E'</span>)flag--;<span class="comment">//左p右p相遇则这个E的所有情况已经罗列完毕，改变标记值回到右p</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">    <span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">    system(<span class="string">"pause"</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="Algorithm" scheme="http://yoursite.com/categories/Algorithm/"/>
    
    
      <category term="Algorithm" scheme="http://yoursite.com/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>LCA</title>
    <link href="http://yoursite.com/2020/03/27/LCA/"/>
    <id>http://yoursite.com/2020/03/27/LCA/</id>
    <published>2020-03-26T16:00:00.000Z</published>
    <updated>2020-04-23T06:44:00.130Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><center><font size=10 color=66ccff>LCA</font></center><p>&emsp;&emsp;LCA(Lowest Common Ancestor)是求两个节点最小公共祖先的算法，就是从树的某两个节点向上回溯，最早相遇的那个节点。这种问题<del>大概</del>有三种解法，st表(也就是倍增优化)、欧拉序、Tarjan算法。</p><font size=6 color=ccccff>st表</font><p>&emsp;&emsp;这种算法的思想就是利用倍增建立st表，非常直接地优化了暴力求解(直接向上遍历)，如果不知道什么是st表，可以通过<a href="https://niemand-co.github.io/2020/03/26/RMQ/#more" target="_blank" rel="noopener">RMQ</a>了解一下。</p><p>&emsp;&emsp;LCA中的倍增操作与RMQ的区别在于RMQ是求区间内的最值，而LCA关注的不是区间，而是两个端点，在一个$anc[i][j]$右端点是左端点相隔$2^j$层的祖先。然后通过这张表，将两个所求节点同步到同一深度，若此时相遇，那么说明已经找到了lca；反之则将两个节点同步向上移直至相遇。</p><p>代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BiNode</span> &#123;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> num;<span class="comment">//记录题目中的主要数据</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">int</span> depth;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BiNode</span> *<span class="title">lChild</span>;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BiNode</span> *<span class="title">rChild</span>;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">&#125;BiNode, *BiTree;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">BiNode *anc[N][N];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> k;<span class="comment">//所能移动的最大高度的对数值</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> d[N];<span class="comment">//对应各个节点的数组，防止移动出错</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line"><span class="comment">//初始化st表</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(BiTree r)</span></span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">    d[r-&gt;num]=r-&gt;depth;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">while</span>(r-&gt;lChild)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">        anc[r-&gt;lChild-&gt;num][<span class="number">0</span>]=r;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">        init(r-&gt;lChild);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">while</span>(r-&gt;rChild)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">        anc[r-&gt;rChild-&gt;num][<span class="number">0</span>]=r;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">        init(r-&gt;rChild);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">25</span></pre></td><td class="code"><pre><span class="line"><span class="comment">//推进st表，使得i、j完整记录</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">26</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Build</span><span class="params">()</span></span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">27</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;(<span class="number">1</span>&lt;&lt;j)&lt;=N;++j)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">28</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N;++i)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">29</span></pre></td><td class="code"><pre><span class="line">            anc[i][j]=anc[anc[i][j<span class="number">-1</span>]-&gt;num][j<span class="number">-1</span>];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">30</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">31</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">32</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">33</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">34</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LCA</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">35</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">if</span>(d[a]&lt;d[b])swap(a,b);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">36</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">int</span> tmp=<span class="keyword">int</span>(<span class="built_in">log</span>(d[a]-d[b])/<span class="built_in">log</span>(<span class="number">2</span>));</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">37</span></pre></td><td class="code"><pre><span class="line">    a=anc[a][tmp]-&gt;num;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">38</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">if</span>(a==b)<span class="keyword">return</span> a;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">39</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">else</span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">40</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=k;i&gt;=<span class="number">0</span>;--i)&#123;<span class="comment">//从最大开始可以精确地移动到lca的下位</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">41</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">if</span>(anc[a][i]!=anc[b][i])&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">42</span></pre></td><td class="code"><pre><span class="line">                a=anc[a][i]-&gt;num;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">43</span></pre></td><td class="code"><pre><span class="line">                b=anc[b][i]-&gt;num;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">44</span></pre></td><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">45</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">46</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">47</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">return</span> anc[a][<span class="number">0</span>]-&gt;num;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">48</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><p>&emsp;&emsp;将这一算法写成链表是为了方便理解，更加直观，但实际中可以直接用数组完成。一般用$fa[]$数组直接记录各个节点的父节点，记录内容是上述结构体中的num的值。然后同样建立depth数组表示深度方便移动。只是将各种结构体操作替换掉就行了。</p><hr><font size=6 color=ccccff>欧拉序</font><p>&emsp;&emsp;首先来了解一下什么是欧拉序(也顺便带一下dfs序)。其实这两种序都是对于一棵二叉树通过dfs得到的一种节点序列。</p><p>先给一个二叉树：</p><p><img src="https://bkimg.cdn.bcebos.com/pic/9213b07eca806538fa88f4329adda144ad3482b5?x-bce-process=image/watermark,g_7,image_d2F0ZXIvYmFpa2U4MA==,xp_5,yp_5" alt="二叉树"></p><p>dfs序：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">F C A D B E H G M</span></pre></td></tr></table></figure><p>欧拉序：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">F C A C D B D C F E H E G M G E F</span></pre></td></tr></table></figure><p>节点为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BiNode</span> &#123;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> depth;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">char</span> ch;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BiNode</span> *<span class="title">lChild</span>;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BiNode</span> *<span class="title">rChild</span>;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">&#125;BiNode, *BiTree;</span></pre></td></tr></table></figure> <details>     <summary>dfs序</summary>     <pre><code>     stack<BiTree> q;     char dfs[N];     int i=0;     void dfs_order(BiTree t){     q.push(t);     while(!q.empty()){         BiTree tmp = q.top();         q.pop();         dfs[i++]=tmp->ch;         if(tmp->rChild)q.push(tmp->rChild);         if(tmp->lChild)q.push(tmp->lChild);         }     }     </code></pre> </details><p>&emsp;&emsp;欧拉序的代码实现如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> Euler[N];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> [N]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i=<span class="number">0</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Euler_order</span><span class="params">(BiTree t)</span></span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    Euler[i++]=t-&gt;ch;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">    d[i]=t-&gt;depth;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">if</span>(t-&gt;lChild)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">        Euler_order(t-&gt;lChild);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">        Euler[i++]=t-&gt;ch;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">        d[i]=t-&gt;depth;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">if</span>(t-&gt;rChild)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">        Euler_order(t-&gt;rChild);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">        Euler[i++]=t-&gt;ch;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">        d[i]=t-&gt;depth;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><div class="table-container"><table><thead><tr><th>序号</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th><th>8</th><th>9</th><th>10</th><th>11</th><th>12</th><th>13</th><th>14</th><th>15</th><th>16</th><th>17</th></tr></thead><tbody><tr><td>节点</td><td>F</td><td>C</td><td>A</td><td>C</td><td>D</td><td>B</td><td>D</td><td>C</td><td>F</td><td>E</td><td>H</td><td>E</td><td>G</td><td>M</td><td>G</td><td>E</td><td>F</td></tr><tr><td>深度</td><td>1</td><td>2</td><td>3</td><td>2</td><td>3</td><td>4</td><td>3</td><td>2</td><td>1</td><td>2</td><td>3</td><td>2</td><td>3</td><td>4</td><td>3</td><td>2</td><td>1</td></tr></tbody></table></div><p>&emsp;&emsp;上面的表格就是得到的欧拉序的表格。此时如何的到lca呢？先取A和M为例。看图可知lca为F。根据欧拉序的特点，连个节点的lca肯定是在序列中AM之间的某点，而lca肯定是之间深度最小的那个节点，也就是说我们先要找到最接近的A和M，然后得到两点之间的深度最小点就是答案了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> tmpl,tmpr,ans=<span class="number">0xffffff</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">query</span><span class="params">(<span class="keyword">char</span> l,<span class="keyword">char</span> r)</span></span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="keyword">sizeof</span>(Euler);++i)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">if</span>(Euler[i]==l)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">            tmpl=i;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="keyword">sizeof</span>(Euler);++i)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">if</span>(Euler[i]==r)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">            tmpr=i;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">break</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=tmpl;i&lt;=tmpr;++i)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">        ans=Euler[ans]&lt;Euler[i]?ans:i;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><p>&emsp;&emsp;得到的ans就是lca在欧拉序中的序号，然后就可与用Euler数组得到lca的值了。</p><hr><font size=6 color=ccccff>Tarjan</font><p>&emsp;&emsp;这种算法其实也是基于dfs的一种算法，建立一个$fa[N]$数组用于记录一个节点的当前祖先节点。</p><p>&emsp;&emsp;在dfs开始时经过的每个节点初始化为$fa[x]=x$，并且记录访问，然后当搜索到叶节点时开始回溯，回溯过程中，经过已经访问过的点时，更新$fa[n]$为父节点，若所求点的其中一个在这条路上，$fa[x]=fa[fa[x]]$，此时回溯到父节点，搜索父节点的另一子节点(如果没有则再向上回溯一层同时不断向上更新$fa[x]$ )，如果在另一子节点及其下辖的一棵子树，也进行相同的操作，同时如果访问到另一点$y$，此时查看标记数组$vis[x]$如果已经被访问过，那么lca就是上面的父节点。后面的全都进行此操作，总体顺序就是一找dfs的从左下角的子树逐渐放大的过程，将每个父节点一次当做子树的根，如果所求两点恰好分布在该父节点两边，则该父节点就是lca。</p><p>代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> vis[<span class="number">101</span>];<span class="comment">//标记是否访问</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> fa[<span class="number">101</span>];<span class="comment">//表示节点的父坐标</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> nex[<span class="number">101</span>][<span class="number">2</span>];<span class="comment">//这里的算法演示仅用于二叉树，多叉可以扩大第二下标，并在Tarjan中用循环</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reset</span><span class="params">()</span></span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">101</span>;++i)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">        fa[i]=i;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">        vis[i]=<span class="number">0</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getfa</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">return</span> fa[x]==x?x:getfa(fa[x]);<span class="comment">//节点压缩，父节点记录为当前回溯最高点</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Tarjan</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">    vis[n]=<span class="number">1</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">if</span>(nex[n][<span class="number">0</span>])&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">        Tarjan(nex[n][<span class="number">0</span>],x,y);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">        fa[nex[n][<span class="number">0</span>]]=n;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">if</span>(nex[n][<span class="number">1</span>])&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line">        Tarjan(nex[n][<span class="number">1</span>],x,y);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line">        fa[nex[n][<span class="number">1</span>]]=n;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">25</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">26</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">if</span>(vis[x]&amp;&amp;vis[y])&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">27</span></pre></td><td class="code"><pre><span class="line">        <span class="built_in">cout</span>&lt;&lt;getfa(x)&lt;&lt;<span class="built_in">endl</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">28</span></pre></td><td class="code"><pre><span class="line">        vis[x]=vis[y]=<span class="number">0</span>;<span class="comment">//只用于求一对解，如果求x与多个y的lca等多种情况可以修改</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">29</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">30</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
    
      <category term="Algorithm" scheme="http://yoursite.com/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>RMQ</title>
    <link href="http://yoursite.com/2020/03/26/RMQ/"/>
    <id>http://yoursite.com/2020/03/26/RMQ/</id>
    <published>2020-03-25T16:00:00.000Z</published>
    <updated>2020-03-27T05:17:22.678Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><center><font size=10 color=66ccff>RMQ</font></center><p>&emsp;&emsp;RMQ(Range Minimum/Maximum Query)是一种求区间内最大值或者最小值的算法，这里用st表来实现。</p><p>&emsp;&emsp;st表首先就是需要倍增算法，以此来降低时间复杂度，那么就先来了解一下倍增算法。众所周知，任何数都能很容易地表示成二进制，倍增就是以2为底数，因此在二进制中表现良好，只需要进行一次位运算的左移就行了。</p><p>&emsp;&emsp;我们先建立一个数组$s[i][j]$,表示$a[i]到a[i+2^j-1]$的最值，通过倍增的预处理先将表填满，之后就可以通过$O(1)$的操作，直接得到所求值。(虽然在只求值一次的情况下还没有传统的遍历来的快)</p><p>&emsp;&emsp;建表的过程其实就是dp，而每次的子问题就是$s[i][j]到s[i][j-1]$之间的最值，毕竟作为质数，差1就是差一倍，这就是表示方便之处。以j为外层循环，i为内层循环，一层一层将表填满。</p><p>代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RMQ</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">        s[i][<span class="number">0</span>]=a[i];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;k;++j)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">if</span>(i+(<span class="number">1</span>&lt;&lt;j)<span class="number">-1</span>&lt;=n)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">                s[i][j]=min(s[i][j<span class="number">-1</span>],s[i+(<span class="number">1</span>&lt;&lt;(j<span class="number">-1</span>))<span class="number">-1</span>][j]);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">                <span class="comment">//s[i][j]=max(s[i][j-1],s[i+(1&lt;&lt;(j-1))-1][j]);</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><p>&emsp;&emsp;st表已经建立好了，剩下的就是$O(1)$的查询操作了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">int</span> tmp=<span class="keyword">int</span>(<span class="built_in">log</span>(b-a+<span class="number">1</span>)/<span class="built_in">log</span>(<span class="number">2</span>));</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">return</span> s[a][tmp];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
    
      <category term="Algorithm" scheme="http://yoursite.com/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>DP and DFS</title>
    <link href="http://yoursite.com/2020/03/14/DP-and-DFS/"/>
    <id>http://yoursite.com/2020/03/14/DP-and-DFS/</id>
    <published>2020-03-13T16:00:00.000Z</published>
    <updated>2020-03-14T03:49:50.284Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><font size=6 color=66ccff>DP and DFS</font><p>&emsp;&emsp;DP(Dynamic Planning)和DFS(Depth First Search)分别是两种十分重要的算法。然而在刷题的过程中，我才发现我一直混淆了两者的思想。</p><p>&emsp;&emsp;动态规划的思想看来看去就是将大问题分解为小问题，且拥有相同的最优解，以此为基本思想向下细化题目或者向上套娃解题。</p><p>&emsp;&emsp;深度优先搜索，可以认为是一种暴力搜索，生成递归树，遍历所有可能后回溯。</p><p>先举个简单的DP的例子：</p><hr><p>&emsp;&emsp;有N个石头，每个石头有一定的高度，青蛙从第一个石头开始，每次跳一步或两步，每次跳过的高度差绝对值计入总值，求解最小总值。</p><hr><p>&emsp;&emsp;这是一道教科书般的DP题，但由于学艺不精，想到的是用递归树找到所有能够到达终点的走法，并且每次回溯时将其最小总值记录。这种方法将原本的$O(n)$级的运算变成了$O(2^n)$级，极大地破坏了算法的效率。</p><p>&emsp;&emsp;因此，为了实现那$O(n)$级的运算，我们需要真正的dp，那就需要化简最小子问题，要求到第N个石头的最小总值首先需要保证到达N-1或N-2个石头的总值最小，以此类推，就可以从最小子问题，也就是到达第1个石头的最小总之，再逐步向上。</p><p>&emsp;&emsp;之后就是对于第N个石头的总值最小的就是$min(n-1\rightarrow n,n-2\rightarrow n)$,循环遍历一次，就能得到$O(n)$的算法。</p><hr><p>&emsp;&emsp;由此例子可以想到dp和dfs的分歧点在于是否需要在一条线上走到底。用二叉树在表示就相当于从父节点出去两个子树，在dfs中需要两个子树都继续展开得到最小子叶，也就是N的总值；而对于dp来说，可以在根节点到两个子节点时就直接判断并且只选择一条路，每次选择都比dfs少掉一般的运算量。</p><p>&emsp;&emsp;这么说dfs的应用场景就是那些不走到最后得不到答案的分支问题，最简单的例如几个元素的全排列。</p><p><del>感觉自己有点学起来了，于是又刷了几道经典dp</del></p><hr><font size=5 color=66ccff>0-1背包问题</font><p>&emsp;&emsp;有N个物品和一个承重W的背包，每个物品重$W_i$价值$v_i$,求能一次性装下的最大总价值的物品。</p><hr><p>&emsp;&emsp;同青蛙跳石问题一样，需要找到最小子问题，也就是确定，在不同背包剩余质量的情况下是否拿取某件物品所获得的最大价值，这就需要建立矩阵，依次遍历不同物品，判断其在不同背包质量下是否拿取的价值，从而得到在背包有W容量的情况下，面对所有物品所能得到的最大价值。</p><p>代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;math.h&gt;</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> w[<span class="number">101</span>],v[<span class="number">101</span>];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> dp[<span class="number">101</span>][<span class="number">100001</span>];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">max</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">return</span> a&gt;b?a:b;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">int</span> N,W;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">    <span class="built_in">cin</span>&gt;&gt;N&gt;&gt;W;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=N;++i)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">        <span class="built_in">cin</span>&gt;&gt;w[i]&gt;&gt;v[i];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=N;++i)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=W;++j)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">if</span>(j&gt;=w[i])&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line">                dp[i][j]=max(dp[i<span class="number">-1</span>][j],dp[i<span class="number">-1</span>][j-w[i]]+v[i]);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line">            &#125;<span class="keyword">else</span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line">                dp[i][j]=dp[i<span class="number">-1</span>][j];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">25</span></pre></td><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">26</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">27</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">28</span></pre></td><td class="code"><pre><span class="line">    <span class="built_in">cout</span>&lt;&lt;dp[N][W]&lt;&lt;<span class="built_in">endl</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">29</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">30</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><hr><font size=5 color=66ccff>最大公共子序列</font><p>&emsp;&emsp;给出两端字符串，得到他们的最大子序列(由两个字符串中共有的字符(不一定连续)组成的字符串)。</p><hr><p>&emsp;&emsp;这种问题也是建立矩阵，行列分别是两个字符串，每一个坐标代表从两个字符串开头开始的遍历到达此处时所得到的最大子序列长度。</p><p>&emsp;&emsp;遍历的过程是一行一行遍历，若遇到横竖的字符相同时，则将此坐标的数值相比于左上加一(这是因为一个字符串中的同一个字符不能和另一个字符串中的多个相同字符对应)，</p><p>代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> s[<span class="number">3000</span>];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> t[<span class="number">3000</span>];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> Com[<span class="number">3001</span>][<span class="number">3001</span>];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> lcs[<span class="number">3000</span>];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">    <span class="built_in">cin</span>&gt;&gt;s;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">    <span class="built_in">cin</span>&gt;&gt;t;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="built_in">strlen</span>(s);++i)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="built_in">strlen</span>(t);++j)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">if</span>(s[i]==t[j])</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">                Com[i+<span class="number">1</span>][j+<span class="number">1</span>]=Com[i][j]+<span class="number">1</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">else</span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">                Com[i+<span class="number">1</span>][j+<span class="number">1</span>]=Com[i][j+<span class="number">1</span>]&gt;Com[i+<span class="number">1</span>][j]?Com[i][j+<span class="number">1</span>]:Com[i+<span class="number">1</span>][j];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line">    <span class="built_in">cout</span>&lt;&lt;lcs&lt;&lt;<span class="built_in">endl</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">25</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><p>&emsp;&emsp;这样一波操作之后就会得到一个如上描述的矩阵，以下面的一个输入为例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">axyb</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">abyxb</span></pre></td></tr></table></figure><p>&emsp;&emsp;经过dp后得到如下矩阵:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">    a b y x b</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">  0 0 0 0 0 0</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">a 0 1 1 1 1 1</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">x 0 1 1 1 2 2</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">y 0 1 1 2 2 2</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">b 0 1 2 2 2 3</span></pre></td></tr></table></figure><p>&emsp;&emsp;周围的一圈’0’是为了防止溢出保证安全。为了得到答案，我们还需要从右下角的点回溯顺着子序列长度增长的路径将子序列打印出(必要时可以用字符数组进行反向)。</p><p>&emsp;&emsp;但观察一下就会发现经过某些非对应坐标点(两字符串相应的字符不相同的座标的点)，可能也会被打印出来，这是因为在正向遍历的时候，遇到对应相同的字符的时候，横纵坐标均加一，而遇到不相同的字符时，则会继承上一点的子序列长度，从而使得子序列增长在矩阵中并非按照完美的斜线，这就需要在回溯时加以判断。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BackTracking</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">if</span>(Com[i][j]==Com[i<span class="number">-1</span>][j<span class="number">-1</span>]+<span class="number">1</span>&amp;&amp;i&gt;<span class="number">0</span>&amp;&amp;j&gt;<span class="number">0</span>&amp;&amp;s[i<span class="number">-1</span>]==t[j<span class="number">-1</span>])&#123;<span class="comment">//判断是否左上为子序列上一个字符来源</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">        lcs[Com[i][j]<span class="number">-1</span>]=s[i<span class="number">-1</span>];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">        BackTracking(i<span class="number">-1</span>,j<span class="number">-1</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(i==<span class="number">0</span>||j==<span class="number">0</span>)<span class="comment">//回溯到头结束</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">return</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">else</span> &#123;<span class="comment">//若不是则找到上一个来源</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">if</span>(Com[i][j]==Com[i<span class="number">-1</span>][j])</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">            BackTracking(i<span class="number">-1</span>,j);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">if</span>(Com[i][j]==Com[i][j<span class="number">-1</span>])</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">            BackTracking(i,j<span class="number">-1</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
    
      <category term="Algorithm" scheme="http://yoursite.com/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>An Interpreter For Scheme</title>
    <link href="http://yoursite.com/2020/02/13/A-Interpreter-For-Scheme/"/>
    <id>http://yoursite.com/2020/02/13/A-Interpreter-For-Scheme/</id>
    <published>2020-02-12T16:00:00.000Z</published>
    <updated>2020-02-16T03:06:29.196Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><font size=5 color=66ccff>An Interpreter For Scheme(C++)</font><p>&emsp;&emsp;一个合格的解释器包括词法分析和语法分析两部，简单来说就是程序知道你写了什么并懂得该怎么做。写一个解释器有不同的方法，出于水平限制，这里选择了用C++来实现一个Scheme的四则运算的解释器。</p><hr><font size=4 color=ccccff>词法分析</font><p>&emsp;&emsp;词法分析要做的就是按序读入并识别字符，为语法分析做好准备。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> pro;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="built_in">cin</span>&gt;&gt;pro;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> *s = (<span class="keyword">char</span>*)pro.data();<span class="comment">//方便单个字符的识别</span></span></pre></td></tr></table></figure><hr><font size=4 color=ccccff>语法分析</font><p>&emsp;&emsp;首先知道Scheme的语句不是简单的字符串，而是一种数据结构。它的语法结构可以用抽象语法树来直接表示，也就是某种二叉树，每个节点表示一个操作，左右子树表示参数，这样对于一般的四则运算，只需要进行一次中序遍历就成了我们一般习惯的算式表达形式。</p><p>&emsp;&emsp;那么我们先观察Scheme语句的基本形式，每个操作都在括号内进行，并且括号之间有嵌套关系，那么我们就可以将每一对括号及其内部的语句看成是一株子树。</p><p>&emsp;&emsp;举个例子:</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">&gt;(+ 5 (- 5 3))</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">&gt;7</span></pre></td></tr></table></figure><p>&emsp;&emsp;这么一个式子它的计算顺序是先内部括号里的$5-3$得$2$,然后再试外部括号的$5+2$得$7$.这种看起来和我们计算习惯有着很大出入的算式表达却和AST(抽象语法树)有着极好的契合。将该式转化为AST，根节点就是$+$操作,左子树就是$5$,右子树就是整个内部括号，而以内部括号为一棵子树，父节点是$-$,左子树是5，右子树是3.</p><p>&emsp;&emsp;根据这一点就可以写出将输入的字符串转化为AST。此处要解决的就是对于每个字符的识别。而Scheme最常见的括号可以成为很好的标识符。大概思路如下。</p><blockquote><p>①遇到左括号则读入下一个操作符，并建立父节点</p><p>②按序读入下两个参数，若遇到左括号则重复①(子节点为新的父节点)</p><p>③每遇到右括号则回溯一层(指针向上移一层)</p><p>④遇到最外层的右括号(指针回到最上层)结束读入语句</p><p>⑤在执行时，从叶开始中序遍历，进行全树收束得到结果</p></blockquote><p>代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BiNode</span> &#123;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> ch;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BiNode</span> *<span class="title">lChild</span>;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BiNode</span> *<span class="title">rChild</span>;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">&#125;AST;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> pro;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BiNode</span> &#123;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> pr;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> num;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> flag;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BiNode</span> *<span class="title">father</span>;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BiNode</span> *<span class="title">lChild</span>;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BiNode</span> *<span class="title">rChild</span>;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">&#125;AST;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line"><span class="comment">//判断是否是表示数字的字符</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">isNum</span><span class="params">(<span class="keyword">char</span> n)</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((n - <span class="number">48</span>) &lt;= <span class="number">9</span> &amp;&amp; (n - <span class="number">48</span>) &gt;= <span class="number">0</span>)<span class="keyword">return</span> <span class="number">1</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line"><span class="comment">//得到一位或多位的数字</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">25</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rNum</span><span class="params">(<span class="keyword">char</span> *(&amp;n))</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">26</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> num = <span class="number">0</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">27</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (n != <span class="literal">NULL</span> &amp;&amp; isNum(*n)) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">28</span></pre></td><td class="code"><pre><span class="line">num = num * <span class="number">10</span> + <span class="keyword">int</span>(*n) - <span class="number">48</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">29</span></pre></td><td class="code"><pre><span class="line">n++;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">30</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">31</span></pre></td><td class="code"><pre><span class="line">n--;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">32</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> num;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">33</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">34</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">35</span></pre></td><td class="code"><pre><span class="line"><span class="comment">//实现四则运算</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">36</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cal</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">char</span> pr)</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">37</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> ans;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">38</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (pr) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">39</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="string">'+'</span>: &#123;ans = l + r; <span class="keyword">break</span>; &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">40</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="string">'-'</span>: &#123;ans = l - r; <span class="keyword">break</span>; &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">41</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="string">'*'</span>: &#123;ans = l * r; <span class="keyword">break</span>; &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">42</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="string">'/'</span>: &#123;ans = l / r; <span class="keyword">break</span>; &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">43</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">default</span>: &#123;<span class="built_in">cout</span> &lt;&lt; <span class="string">"ERROR"</span> &lt;&lt; <span class="built_in">endl</span>; <span class="keyword">return</span> <span class="number">0</span>; &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">44</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">45</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> ans;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">46</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">47</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">48</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">read</span><span class="params">(AST *t, AST *h, <span class="keyword">char</span> *(&amp;s))</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">49</span></pre></td><td class="code"><pre><span class="line">t-&gt;flag = <span class="number">0</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">50</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (*s == <span class="string">')'</span>)<span class="keyword">return</span>;<span class="comment">//结束分析开始收束</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">51</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (t != h &amp;&amp; s == <span class="literal">NULL</span>) &#123;<span class="comment">//错误处理</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">52</span></pre></td><td class="code"><pre><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"ERROR"</span> &lt;&lt; <span class="built_in">endl</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">53</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">54</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">55</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (*s == <span class="string">'('</span>) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">56</span></pre></td><td class="code"><pre><span class="line">t-&gt;pr = *(++s);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">57</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">58</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">59</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (*(++s) != <span class="string">' '</span> || *(++s) == <span class="string">' '</span>) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">60</span></pre></td><td class="code"><pre><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"ERROR"</span> &lt;&lt; <span class="built_in">endl</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">61</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">62</span></pre></td><td class="code"><pre><span class="line">&#125;<span class="comment">//判空报错</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">63</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (*s == <span class="string">'('</span>) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">64</span></pre></td><td class="code"><pre><span class="line">t-&gt;lChild = (AST*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(AST));</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">65</span></pre></td><td class="code"><pre><span class="line">read(t-&gt;lChild, h, s);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">66</span></pre></td><td class="code"><pre><span class="line">++s;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">67</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">68</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (isNum(*s)) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">69</span></pre></td><td class="code"><pre><span class="line">t-&gt;lChild = (AST*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(AST));</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">70</span></pre></td><td class="code"><pre><span class="line">t-&gt;lChild-&gt;num = rNum(s);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">71</span></pre></td><td class="code"><pre><span class="line">t-&gt;lChild-&gt;flag = <span class="number">1</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">72</span></pre></td><td class="code"><pre><span class="line">&#125;<span class="comment">//第一个参数</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">73</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">74</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">75</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (*(++s) != <span class="string">' '</span> || *(++s) == <span class="string">' '</span>) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">76</span></pre></td><td class="code"><pre><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"ERROR"</span> &lt;&lt; <span class="built_in">endl</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">77</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">78</span></pre></td><td class="code"><pre><span class="line">&#125;<span class="comment">//判空报错</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">79</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (*s == <span class="string">'('</span>) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">80</span></pre></td><td class="code"><pre><span class="line">t-&gt;rChild = (AST*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(AST));</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">81</span></pre></td><td class="code"><pre><span class="line">read(t-&gt;rChild, h, s);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">82</span></pre></td><td class="code"><pre><span class="line">++s;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">83</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">84</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (isNum(*s)) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">85</span></pre></td><td class="code"><pre><span class="line">t-&gt;rChild = (AST*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(AST));</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">86</span></pre></td><td class="code"><pre><span class="line">t-&gt;rChild-&gt;num = rNum(s);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">87</span></pre></td><td class="code"><pre><span class="line">t-&gt;rChild-&gt;flag = <span class="number">1</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">88</span></pre></td><td class="code"><pre><span class="line">&#125;<span class="comment">//第二个参数</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">89</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">90</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">91</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">92</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MidTraverse</span><span class="params">(BiNode *t)</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">93</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (t == <span class="literal">NULL</span>)<span class="keyword">return</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">94</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (t-&gt;flag)<span class="keyword">return</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">95</span></pre></td><td class="code"><pre><span class="line">MidTraverse(t-&gt;lChild);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">96</span></pre></td><td class="code"><pre><span class="line">MidTraverse(t-&gt;rChild);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">97</span></pre></td><td class="code"><pre><span class="line">t-&gt;num = cal(t-&gt;lChild-&gt;num, t-&gt;rChild-&gt;num, t-&gt;pr);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">98</span></pre></td><td class="code"><pre><span class="line">t-&gt;flag = <span class="number">1</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">99</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">100</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">101</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">102</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">103</span></pre></td><td class="code"><pre><span class="line">getline(<span class="built_in">cin</span>, pro);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">104</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> *s = (<span class="keyword">char</span>*)pro.data();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">105</span></pre></td><td class="code"><pre><span class="line">AST *h = (AST*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(AST));</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">106</span></pre></td><td class="code"><pre><span class="line">read(h, h, s);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">107</span></pre></td><td class="code"><pre><span class="line">MidTraverse(h);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">108</span></pre></td><td class="code"><pre><span class="line"><span class="built_in">cout</span> &lt;&lt; h-&gt;num &lt;&lt; <span class="built_in">endl</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">109</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">110</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">111</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Single-Source Shortest Paths</title>
    <link href="http://yoursite.com/2020/02/09/Single-Source-Shortest-Paths/"/>
    <id>http://yoursite.com/2020/02/09/Single-Source-Shortest-Paths/</id>
    <published>2020-02-08T16:00:00.000Z</published>
    <updated>2020-04-28T05:18:27.425Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><font size=5 color=66ccff>单源最短路径问题(Single-Source Shortest Paths)</font><p>&emsp;&emsp;单源最短路径问题是指从图中的一个点到其它可到达点的最短距离。这种问题一般由两种方法解决，分别是Bellman-Ford和Dijkstra。</p><font size=5 color=ccccff>Bellman-Ford</font><p>&emsp;&emsp;Bellman-Ford算法的主要思想是遍历图中的所有边，若能使需要经过的边的权重和降低，则更新一遍路径。</p><p>&emsp;&emsp;此处的更新用到的主要操作叫做<font color=pink>松弛操作</font>。就是现将每一个节点的距离值设为$\infin$,然后遍历每一条边，若该条边的起点不是无穷大(则表明该点已经经过，若没有经过则不能进行操作)，此时对此边进行松弛操作，松弛操作实现如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">dis[N]<span class="comment">//每个节点的距离值</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(dis[n]&gt;dis[n<span class="number">-1</span>]+edge(n<span class="number">-1</span>,n))</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    dis[n]=dis[n<span class="number">-1</span>]+edge(n<span class="number">-1</span>,n);</span></pre></td></tr></table></figure><p>&emsp;&emsp;在每轮循环中，每次松弛操作进行后进行一次标记，在本次循环结束后，若没有标记，则证明路径没有被更新，那么就表明已经得到了最短路径，此时退出循环。</p><p>代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">edge</span>&#123;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">int</span> from;<span class="comment">//该边起点</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">int</span> to;<span class="comment">//该边重点</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">int</span> cost;<span class="comment">//该边权重</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">&#125;edge;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> V,E;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">edge es[E];<span class="comment">//总共N条边</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> dis[V];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Bellman_Ford</span><span class="params">(<span class="keyword">int</span> s)</span></span>&#123;<span class="comment">//s是源节点</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;V;++i)dis[i]=INF;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">    dis[s]=<span class="number">0</span>;<span class="comment">//源节点距离为0</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">bool</span> update=<span class="literal">false</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;V;++i)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">            edge e = es[i];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line">            <span class="comment">//松弛操作</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">if</span>(dis[e.from]!=INF&amp;&amp;dis[e.to]&gt;dis[e.from]+e.cost)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line">                dis[e.to]=dis[e.from]+e.cost;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">25</span></pre></td><td class="code"><pre><span class="line">                update=<span class="literal">true</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">26</span></pre></td><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">27</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">28</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">if</span>(!update)<span class="keyword">break</span>;<span class="comment">//已经得到最小路径</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">29</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">30</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">return</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">31</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><hr><font size=5 color=ccccff>Dijkstra</font><p>&emsp;&emsp;Dijkstra算法本质上是一种贪心算法，对图进行多次的操作，最终得到一棵最短路径树。这种算法用邻接矩阵表示会更加直观。每次执行算法先确定源节点，执行结束的时候将得到一个数组，内含各个可到达节点和源节点之间的距离值。</p><p>&emsp;&emsp;细说上面所指的操作。观察源节点所指向的那一行，即是由源节点指向其它节点的距离值，$\infin$代表无法直接到达，而在$dis$数组里一开始存放的就是能从源节点一步到达的其它节点的距离值。每次循环根据贪心思想找到距离值最小的其它节点(A)，再去遍历该其它节点在邻接矩阵对应的那一行，将得到的距离值再加上这个节点(A)和别的节点(B,C…..)之间的边的权重，这也就是新的节点(B,C…..)到源节点的距离值，若能小于从源节点一步到达的距离(即源节点行的权重值)则进行一次更新(但如果原本该点的距离值是$\infin$，此时变为某个确定值则代表该点通过两步或更多步能够从源节点到达)。</p><p>&emsp;&emsp;这样经过多次循环更新，直至某次完全没有更新发生，说明数组中的每一个值哦度已经达到了最小值。此时完成Dijkstra。</p><p>代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> <span class="built_in">map</span>[N][N];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> vis[N];<span class="comment">//用于标记已经用于更新的其它节点，相当于已经走过的路的第一步</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> dis[N];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;<span class="comment">//初始化操作</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">    <span class="built_in">memset</span>(<span class="built_in">map</span>,INF,<span class="keyword">sizeof</span>(<span class="built_in">map</span>));</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=N;++i)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">        <span class="built_in">map</span>[i][i]=<span class="number">0</span>;<span class="comment">//自己与自己距离为零</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Dijkstra</span><span class="params">(<span class="keyword">int</span> s)</span></span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">    <span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="keyword">sizeof</span>(vis));</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">    vis[s]=<span class="number">1</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> step=<span class="number">1</span>;step&lt;N;++step)&#123;<span class="comment">//每一个点都有延伸的路线，源节点自己不算</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">int</span> min=INF,temp=<span class="number">0</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=N;++i)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">if</span>(!vis[i]&amp;&amp;dis[i]&lt;min)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line">                min=dis[i];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line">                temp=i;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">25</span></pre></td><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">26</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">27</span></pre></td><td class="code"><pre><span class="line">        vis[temp]=<span class="number">1</span>;<span class="comment">//标记表示已经走过这条路，下次循环便不再走</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">28</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=N;++i)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">29</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">if</span>(<span class="built_in">map</span>[temp][i]+dis[temp]&lt;dis[i])&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">30</span></pre></td><td class="code"><pre><span class="line">                dis[i]=<span class="built_in">map</span>[temp][i]+dis[temp];<span class="comment">//更小距离值的更新操作</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">31</span></pre></td><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">32</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">33</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">34</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
    
      <category term="Algorithm" scheme="http://yoursite.com/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>Graph Algorithm</title>
    <link href="http://yoursite.com/2020/01/31/Grapg-Algorithm/"/>
    <id>http://yoursite.com/2020/01/31/Grapg-Algorithm/</id>
    <published>2020-01-30T16:00:00.000Z</published>
    <updated>2020-02-09T16:23:34.959Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><font size=10 color=66ccff>Graph Algorithm</font><p>&emsp;&emsp;图的表示方式可以有两种，邻接链表和邻接矩阵。</p><p><img src="E:\blog\source\images\b03ef32f6b262022f62297978840fc3f.jpg" style="zoom: 33%;" /></p><center>邻接链表</center><img src="E:\blog\source\images\72af3a658973869feeae7660e3b881e6.png" style="zoom:33%;" /><center>连接矩阵</center>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
    
      <category term="Algorithm" scheme="http://yoursite.com/tags/Algorithm/"/>
    
      <category term="Data Structure" scheme="http://yoursite.com/tags/Data-Structure/"/>
    
  </entry>
  
  <entry>
    <title>Tree</title>
    <link href="http://yoursite.com/2020/01/14/Tree/"/>
    <id>http://yoursite.com/2020/01/14/Tree/</id>
    <published>2020-01-14T03:18:35.000Z</published>
    <updated>2020-01-25T14:08:55.239Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><hr><font size=10 color=66ccff>二叉树(Binary Tree)</font><p>&emsp;&emsp;二叉树是一种树形数据结构，它的特点是每一个节点下面最多有两个子树。这种树的结构一般有二叉链表来写。</p><p><img src="https://gss2.bdstatic.com/9fo3dSag_xI4khGkpoWK1HF6hhy/baike/w%3D268%3Bg%3D0/sign=2a18a9f5b9a1cd1105b675268129afc1/8644ebf81a4c510f0b3dafdf6359252dd52aa57e.jpg" alt=""></p><p>&emsp;&emsp;下面是这种二叉树的创建和简单操作：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++&gt;</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BiNode</span> &#123;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> ch;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BiNode</span> *<span class="title">lChild</span>;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BiNode</span> *<span class="title">rChild</span>;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">&#125;BiNode, *BiTree;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建树</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CreateBitree</span><span class="params">(BiTree &amp;t)</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> c;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line"><span class="built_in">cin</span> &gt;&gt; c;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (c == <span class="string">'#'</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">t=<span class="literal">NULL</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">t = <span class="keyword">new</span> BiNode;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">t-&gt;ch = c;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">CreateBitree(t-&gt;lChild);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line">CreateBitree(t-&gt;rChild);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">25</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">26</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">27</span></pre></td><td class="code"><pre><span class="line"><span class="comment">//正序遍历</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">28</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PreTaverse</span><span class="params">(BiNode *t)</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">29</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (t == <span class="literal">NULL</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">30</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">31</span></pre></td><td class="code"><pre><span class="line"><span class="built_in">cout</span> &lt;&lt; t-&gt;ch &lt;&lt; <span class="built_in">endl</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">32</span></pre></td><td class="code"><pre><span class="line">PreTaverse(t-&gt;lChild);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">33</span></pre></td><td class="code"><pre><span class="line">PreTaverse(t-&gt;rChild);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">34</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">35</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">36</span></pre></td><td class="code"><pre><span class="line"><span class="comment">//中序遍历</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">37</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MidTraverse</span><span class="params">(BiNode *t)</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">38</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (t == <span class="literal">NULL</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">39</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">40</span></pre></td><td class="code"><pre><span class="line">MidTraverse(t-&gt;lChild);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">41</span></pre></td><td class="code"><pre><span class="line"><span class="built_in">cout</span> &lt;&lt; t-&gt;ch &lt;&lt; <span class="built_in">endl</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">42</span></pre></td><td class="code"><pre><span class="line">MidTraverse(t-&gt;rChild);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">43</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">44</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">45</span></pre></td><td class="code"><pre><span class="line"><span class="comment">//倒序遍历</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">46</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PostTraverse</span><span class="params">(BiNode *t)</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">47</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (t == <span class="literal">NULL</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">48</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">49</span></pre></td><td class="code"><pre><span class="line">PostTraverse(t-&gt;lChild);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">50</span></pre></td><td class="code"><pre><span class="line">PostTraverse(t-&gt;rChild);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">51</span></pre></td><td class="code"><pre><span class="line"><span class="built_in">cout</span> &lt;&lt; t-&gt;ch &lt;&lt; <span class="built_in">endl</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">52</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">53</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">54</span></pre></td><td class="code"><pre><span class="line"><span class="comment">//递归法求树的深度</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">55</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Bi_Depth</span><span class="params">(BiTree T)</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">56</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (T == <span class="literal">NULL</span>)<span class="keyword">return</span> <span class="number">0</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">57</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">58</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> lHeight = Bi_Depth(T-&gt;lChild) + <span class="number">1</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">59</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> rHeight = Bi_Depth(T-&gt;rChild) + <span class="number">1</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">60</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> lHeight ? rHeight : lHeight &gt; rHeight;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">61</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">62</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">63</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">64</span></pre></td><td class="code"><pre><span class="line"><span class="comment">//非递归法求树的深度</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">65</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bi_depth</span><span class="params">(BiTree T)</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">66</span></pre></td><td class="code"><pre><span class="line"><span class="built_in">stack</span>&lt;BiTree&gt; q;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">67</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> depth = <span class="number">0</span>, tmplenth;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">68</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (T == <span class="literal">NULL</span>)<span class="keyword">return</span> <span class="number">0</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">69</span></pre></td><td class="code"><pre><span class="line">q.push(T);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">70</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (!q.empty()) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">71</span></pre></td><td class="code"><pre><span class="line">depth++;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">72</span></pre></td><td class="code"><pre><span class="line">tmplenth = q.size();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">73</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (tmplenth--) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">74</span></pre></td><td class="code"><pre><span class="line">BiTree temp = q.top();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">75</span></pre></td><td class="code"><pre><span class="line">q.pop();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">76</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (temp-&gt;lChild)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">77</span></pre></td><td class="code"><pre><span class="line">q.push(temp-&gt;lChild);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">78</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (temp-&gt;rChild)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">79</span></pre></td><td class="code"><pre><span class="line">q.push(temp-&gt;rChild);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">80</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">81</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">82</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> depth;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">83</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><hr><font size=10 color=66ccff>二叉搜索树(Binary Search Tree)</font><p>&emsp;&emsp;二叉搜索树，又叫二叉查找树或二叉排序树，因此也就不难想到这种结构的特点，那就是对于每一个节点，他本身的值大于左子树的值，小于右子树的值。以此构造的树，在一次中序遍历后可以得到一个有序数列。那么每次插入的值就需要在每一层次进行比较，这也就使得这种结构的树并不是平衡的，甚至会出现一棵树变成一个数组的情况。</p><p>&emsp;&emsp;对于一棵满二叉树(即每个非叶节点都有左右两个子树)，他的结点数$n$和高度$h$的关系就是$n=2^h-1$,那么高度$h=\log_2(n+1)$.</p><p>&emsp;&emsp;那么让我们来看一下二叉搜索树的查找操作。他是在给定指向节点的指针和所需要查询的值$key$得情况下进行的。将$key$值与节点值进行比较，若相等怎返回节点(即为所找的点)；若不相等，则判断$key$值相比节点值是大还是小，若小于节点值，则将节点指针指向根的左子树，若大于则指向右子树，将新的节点作为根继续和$key$值比较判断。</p><p>&emsp;&emsp;由上可知，在查找一棵满二叉树的情况下，每一层进行一次比较，做大查找时间复杂度就是$O(\log n)$级的，即查找长度最大相当于树高$h$。但在遇到二叉搜索树近似于一个数组时，此时的最大时间复杂度就是$O(n)$级的，也就相当于在数组中查找。</p><p>代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++&gt;</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"><span class="comment">//结构体创建和普通的二叉树无异</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BST</span>&#123;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">int</span> data;<span class="comment">//add whatever you need.</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BST</span> *<span class="title">lChild</span>;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BST</span> *<span class="title">rChild</span>;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">&#125;BiNode,*BST;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line"><span class="comment">//二叉搜索树的建立(为了保证有序，一棵二叉搜索树的建立其实就是不断插入的过程，因为每一棵二叉搜索树不一定是满二叉树)</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createBST</span><span class="params">(BST t,<span class="keyword">int</span> d)</span></span>&#123;<span class="comment">//其实和插入是一个操作</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">if</span>(t == <span class="literal">NULL</span>)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">        t=(BST)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BiNode));</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">        t-&gt;data=d;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">        t-&gt;lChild=<span class="literal">NULL</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">        t-&gt;rChild=<span class="literal">NULL</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">return</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BST</span> *<span class="title">temp</span>=<span class="title">t</span>;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">if</span>(d&lt;=t-&gt;data)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line">        createBST(t-&gt;lChild,d);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">25</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(d&gt;t-&gt;data)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">26</span></pre></td><td class="code"><pre><span class="line">        createBST(t-&gt;rChild,d);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">27</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">28</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">29</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">30</span></pre></td><td class="code"><pre><span class="line"><span class="comment">//二叉搜索树的查找</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">31</span></pre></td><td class="code"><pre><span class="line"><span class="function">BST <span class="title">search</span><span class="params">(BST t,<span class="keyword">int</span> d)</span></span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">32</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">if</span>(t == <span class="literal">NULL</span>)<span class="keyword">return</span> <span class="literal">NULL</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">33</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">if</span>(t-&gt;data == d)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">34</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">return</span> t;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">35</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">36</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(d&lt;t-&gt;data)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">37</span></pre></td><td class="code"><pre><span class="line">        search(t-&gt;lChild,d);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">38</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">39</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">else</span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">40</span></pre></td><td class="code"><pre><span class="line">        search(t-&gt;rChild,d);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">41</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">42</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><hr><font size=10 color=66ccff>AVL树</font><p>&emsp;&emsp;AVL树实际上就是一种二叉搜索树，但由于上述提及的二叉搜索树在某些情况下容易失去平衡，或趋于数组。AVL树则是一种自平衡二叉搜索树。他可以做到让每一个节点的左右子树的高度差不超过1。</p><p>&emsp;&emsp;我们都知道破坏一二叉棵树的平衡是由于新插入的值被加入到了最高的叶的左(右)子树，但根据二叉搜索树的有序性，我们可以通过旋转使得在保持有序性的情况下，将最新加入的节点的父节点上提，取代爷爷的位置，让爷爷变成父节点的子树(即成为和破坏平衡的新节点的同辈)。</p><p>&emsp;&emsp;这种将叶上提的操作就是AVL旋转，由于旋转前左右子树高度差最大为2，每一次旋转操作以一个二叉小三角(一个父节点和两个子树的大小)为单位，以其中一个点为原点，旋转另一个节点，并视情况改变两节点与其他节点的连接。主要操作为左旋和右旋。</p><p>&emsp;&emsp;以代际来区别不同层次的节点。将第二代左右节点作为界，分为左右两种对称情况。每种情况对应第二代有一个还是两个子树，①若只有一个子树，则第四代节点有两种存在位置，②若有两个节点，则第四代节点有四种存在位置。</p><blockquote><p>在第二代只有一个节点的情况下</p><blockquote><p>第三代和第四代都是右子树(左子树)，则采用左旋转(右旋转)</p><p>第三代是左(右)子树，第四代是右(左)子树，则采用先左(右)旋再右(左)旋                                                                                                                      </p></blockquote><p>在第二代有两个节点的情况下先以第二代为原点采取左(右)旋，剩下的操作同上</p></blockquote><p>代码实现如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++&gt;</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">AVLT</span>&#123;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">int</span> data;<span class="comment">//add whatever you need.</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">AVLT</span> *<span class="title">lChild</span>;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">AVLT</span> *<span class="title">rChild</span>;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">&#125;BiNode,*AVLT;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line"><span class="function">AVLT <span class="title">rightRotation</span><span class="params">(AVLT t)</span></span>&#123;<span class="comment">//t是指第二代</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">    BiNode *p = t-&gt;lChild;<span class="comment">//p是指第三代</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">    t-&gt;lChild = p-&gt;rChild;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">    p-&gt;rChild = t;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">return</span> p; </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">//此时的p已经取代第二代，成为第一代的左子树，t和第四代成为新的第三代</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line"><span class="comment">//右旋</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line"><span class="function">AVLT <span class="title">rightRotation</span><span class="params">(AVLT t)</span></span>&#123;<span class="comment">//t是指二叉小三角里的父节点</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">    BiNode *p = t-&gt;lChild;<span class="comment">//在右旋中p是左子树</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line">    t-&gt;lChild = p-&gt;rChild;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line">    p-&gt;rChild = t;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">return</span> p; </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">25</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">26</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">27</span></pre></td><td class="code"><pre><span class="line"><span class="comment">//左旋</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">28</span></pre></td><td class="code"><pre><span class="line"><span class="function">AVLT <span class="title">leftRotation</span><span class="params">(AVLT t)</span></span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">29</span></pre></td><td class="code"><pre><span class="line">    BiNode *p = t-&gt;rChild;<span class="comment">//在左旋中p是右子树</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">30</span></pre></td><td class="code"><pre><span class="line">    t-&gt;rChild = p-&gt;lChild;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">31</span></pre></td><td class="code"><pre><span class="line">    p-&gt;rChild = t;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">32</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">return</span> p;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">33</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">34</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">35</span></pre></td><td class="code"><pre><span class="line"><span class="comment">//每次的旋转操作传入的参数是相对上面的那个节点，得到返回的节点指针再与其他节点相连，下面两种旋转的第一次旋转后就有一次连接，最后返回还未被连接的节点指针，进行手动连接</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">36</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">37</span></pre></td><td class="code"><pre><span class="line"><span class="comment">//先左旋再右旋</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">38</span></pre></td><td class="code"><pre><span class="line"><span class="function">AVLT <span class="title">lrRotation</span><span class="params">(AVLT t)</span></span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">39</span></pre></td><td class="code"><pre><span class="line">    t-&gt;lChild = leftRotation(t-&gt;lChild);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">40</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">return</span> rightRotation(t);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">41</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">42</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">43</span></pre></td><td class="code"><pre><span class="line"><span class="comment">//先右旋再左旋</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">44</span></pre></td><td class="code"><pre><span class="line"><span class="function">AVLT <span class="title">rlRotation</span><span class="params">(AVLT t)</span></span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">45</span></pre></td><td class="code"><pre><span class="line">    t-&gt;rChild = rightRotation(t-&gt;rChild);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">46</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">return</span> leftRotation(t);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">47</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><p>&emsp;&emsp;AVL树的插入操作在一开始和一般的二叉搜索树是一样的，都是利用递归进行二分查找再插入。单位了保持平衡，在插入一个节点后，必须判断该树是否失去平衡，若失去平衡，与该采取哪种旋转。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insertAVL</span><span class="params">(AVLT t,<span class="keyword">int</span> d)</span></span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">if</span>(t == <span class="literal">NULL</span>)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">        t=(AVLT)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BiNode));</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">        t-&gt;data=d;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">        t-&gt;lChild=<span class="literal">NULL</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">        t-&gt;rChild=<span class="literal">NULL</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">return</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">    AVLT temp=t;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">if</span>(d&lt;=t-&gt;data)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">        insertAVL(t-&gt;lChild,d);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">        <span class="comment">//此处采用递归，也就是递归每一层都会判断一下所经过节点的左右树高，也就能正确反映失衡情况</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">if</span>(bi_depth(t-&gt;lChild)-bi_depth(t-&gt;rChild)&gt;=<span class="number">2</span>)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">            r=(bi_depth(t-&gt;lChild-&gt;lChild)&gt;bi_depth(t-&gt;lChild-&gt;rChild)?rightRotation(t):lrRotation(t));</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(d&gt;t-&gt;data)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">        insertAVL(t-&gt;rChild,d);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">        r=(bi_depth(t-&gt;rChild-&gt;rChild)&gt;bi_depth(t-&gt;rChild-&gt;lChild)?leftRotation(t):rlRotation(t));</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
    
      <category term="Algorithm" scheme="http://yoursite.com/tags/Algorithm/"/>
    
      <category term="Data Structure" scheme="http://yoursite.com/tags/Data-Structure/"/>
    
  </entry>
  
  <entry>
    <title>Quick Multiply</title>
    <link href="http://yoursite.com/2019/12/10/Quick-Multiply/"/>
    <id>http://yoursite.com/2019/12/10/Quick-Multiply/</id>
    <published>2019-12-09T16:00:00.000Z</published>
    <updated>2019-12-26T10:49:20.064Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><font size=10 color=66ccff>快速乘(Quick Multiply)</font><p>&emsp;&emsp;快速乘是为了应对乘法结果超过数据存储容量的一种算法，他的思想类似于快速幂，都是在乘法过程中不断取模，以保证控制数据大小。</p><p>&emsp;&emsp;那么要做到不断取模，就必须将乘法分段完成，这就需要将其中一个乘数转化为二进制，根据其位数，算出$a$与每一位上的1相乘的结果，再进行判断，若这一二进制位是1，则将该结果与答案相加，反之则跳过。这样就保证了在得到每个$a$与$2^n$的积被及时取模，不至于超范围。</p><script type="math/tex; mode=display">a*b=a*(2^{b_1}+2^{b_2}+\cdots+2^{b_n})</script><p>代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="function">ll <span class="title">Quick_Multiply</span><span class="params">(ll a,ll b,ll mod)</span></span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    ll ans=<span class="number">0</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">while</span>(b)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">if</span>(b&amp;<span class="number">1</span>)&#123;<span class="comment">//判断该二进制位是否为1,来决定是否加上该位的乘积值</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">            ans+=(a%mod)；<span class="comment">//保证每次取模</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">        a&lt;&lt;=<span class="number">1</span>;<span class="comment">//下一二进制位的相乘结果</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">        b&gt;&gt;=<span class="number">1</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">return</span> ans;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="Algorithm" scheme="http://yoursite.com/categories/Algorithm/"/>
    
    
  </entry>
  
  <entry>
    <title>欧拉降幂</title>
    <link href="http://yoursite.com/2019/12/10/%E6%AC%A7%E6%8B%89%E9%99%8D%E5%B9%82/"/>
    <id>http://yoursite.com/2019/12/10/%E6%AC%A7%E6%8B%89%E9%99%8D%E5%B9%82/</id>
    <published>2019-12-09T16:00:00.000Z</published>
    <updated>2019-12-10T05:13:12.788Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script>    <div id="aplayer-gqEtYNGt" class="aplayer aplayer-tag-marker meting-tag-marker"         data-id="30482386" data-server="netease" data-type="song" data-mode="circulation" data-autoplay="false" data-mutex="true" data-listmaxheight="340px" data-preload="auto" data-theme="#555"    ></div><font size=6 color=66ccff>欧拉降幂(Euler Decreasing Power)</font><p>&emsp;&emsp;在讲欧拉降幂之前，先来讲一下欧拉定理(费马-欧拉定理)。而要讲欧拉定理则要先提一下费马小定理(<a href="#jump">费马小定理的证明</a>)，如下：</p><script type="math/tex; mode=display">若(a,p)\ =\ 1,\ 则a^{p-1}\ =\ 1\ (mod\ \ p)</script><p>经欧拉推广(我目前还不会证)，得到欧拉定理<font color=red>(此时需要a和n互质)</font>:</p><script type="math/tex; mode=display">a^{\phi(n)}\ =\ 1\ (mod\ \ n)\\其中n表示在[1,n]中与n互质的数的个数</script><p>&emsp;&emsp;而在编程问题中，欧拉降幂可以再不求出数本身的情况下，取得一个数的模值，这样就避免了计算一些超出数据类型范围的大数据。</p><p>&emsp;&emsp;具体的思想过程是首先确定要取得模为$n$,带求解底数为x,指数为$p$,算出$\phi(n)$的值，得到$x^{\phi(n)} = 1 (mod  n)$。将$x^p$化简成:</p><script type="math/tex; mode=display">x^{\phi(n)*p_1}*x^{p_2}\ (mod\ \ n)</script><p>&emsp;&emsp;再用欧拉定理等价转化上式子，将其进一步化简得$x^{p_2} (mod  n)$。现在已经能够非常简单地算出不会超范围的答案了。</p><p>&emsp;&emsp;在利用欧拉定理前，首先要获得$\phi(n)$的值，而计算$\phi(n)$欧拉也给出了欧拉函数：</p><script type="math/tex; mode=display">\phi(x)\ =\ x*\prod_{i=1}^n(1-\frac{1}{p_i})\\(p_i(i=1,2,\cdots)是n的质因数)</script><p>&emsp;&emsp;让我们把这条式子转化一下，使之更符合编程思路：</p><script type="math/tex; mode=display">\phi(x)\ =\ x*\prod_{i=1}^n\frac{p_i-1}{p_i}</script><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> prime[N];<span class="comment">//通过筛法得到的小于n的素数集合</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="function">ll <span class="title">Euler_phi</span><span class="params">(ll n)</span></span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    ll k=(ll)<span class="built_in">sqrt</span>(n+<span class="number">0.5</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    ll ans=n;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N;++i)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">if</span>(n%prime[i]==<span class="number">0</span>)&#123;<span class="comment">//判断是否为因数</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">            temp=prime[i];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">            ans=ans/temp*(temp<span class="number">-1</span>);<span class="comment">//利用欧拉函数来进行运算</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">while</span>(n%temp==<span class="number">0</span>)n/=temp;<span class="comment">//每个数的每个因数只能出现一次</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">if</span>(n&gt;<span class="number">1</span>)ans=ans/n*(n<span class="number">-1</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">return</span> ans;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><p>&emsp;&emsp;以上是求得欧拉函数的过程，在得到Euler_Phi的值后，我们便可以将所求的幂运算简化成以下式子：</p><script type="math/tex; mode=display">a^b\ =\ a^{b\%phi(n)}\ (mod\ \ n)</script><p>但这还是$a$和$n$互质的情况，推广到一般情况(也就是当$a$和$n$不互质了)则有以下式子：</p><script type="math/tex; mode=display">a^b\equiv\left\{\begin{array}{}a^b\ (mod\ \ n) \ \ \ \ \ b<\phi(n)\\a^{b\%\phi(n)+\phi(n)}\ (mod\ \ n)\ \ \ \ \ b\geqslant\phi(n)\end{array}\right.</script><p>我们可以通过$\phi(n)$判断$a$,$n$是否互质，从而选择公式,再利用快速幂取模运算求得最终的值。(不知道)</p><p>以下是快速幂取模的板子，具体实现在另一篇博客：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">qpo</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> n)</span></span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">int</span> temp=<span class="number">2</span>,ans=<span class="number">1</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">while</span>(n)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">if</span>(n&amp;<span class="number">1</span>)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">            ans*=temp;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">        temp*=temp;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">        n&gt;&gt;=<span class="number">1</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">return</span> ans;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><p><span id="jump"></p><font color=red>费马小定理的证明:</font><p>&emsp;&emsp;$p$的完全剩余系是$\{1,2,\cdots,p-1\}$。</p><blockquote><p>完全剩余系就是一个数的全部剩余类组成</p><p>剩余类即任意数对确定的某个数$n$取模时得到的那个数(因此必定在$[0,n-1]$内)</p></blockquote><p>因为$(a,p) = 1$,那么$\{a,2a,\cdots,a(p-1)\}$也是$p$的一个完全完全剩余系。那么，由完全剩余系的性质得：</p><script type="math/tex; mode=display">1*2*\cdots*(p-1)\ \equiv\ a*2a*\cdots*(p-1)a\ (mod\ \ p)\\\because\ ((p-1),p)=1\\\therefore\ a^{p-1}\ (mod\ \ p)\ \equiv\ 1\\即a^{p-1}\ =\ 1\ (mod\ \ p)</script><p>得证。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="Algorithm" scheme="http://yoursite.com/categories/Algorithm/"/>
    
    
      <category term="Number Theory" scheme="http://yoursite.com/tags/Number-Theory/"/>
    
  </entry>
  
  <entry>
    <title>Ehrlich Sieve and Linear Sieve</title>
    <link href="http://yoursite.com/2019/12/09/Ehrlich-Sieve-and-Linear-Sieve/"/>
    <id>http://yoursite.com/2019/12/09/Ehrlich-Sieve-and-Linear-Sieve/</id>
    <published>2019-12-08T16:00:00.000Z</published>
    <updated>2019-12-10T02:16:09.985Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><font size=10 color=66ccff>埃氏筛（Ehrlich Sive）</font><p>&emsp;&emsp;我们经常在解题时被要求得到一定范围内所有的素数，而我们一般的做法是在范围内遍历，对于每一个值进行筛选(顶多就是把范围缩小到二分之一次方级)。但这种做法在很多情况下是不足以满足速度需求的，因此就需要采取不一样的素数判断方法。</p><p>&emsp;&emsp;我们都知道，最小的素数是2。那么，2的倍数肯定都不是素数，因为它们的因数除了自己和1起码还有个2。以此类推，3的倍数、5的倍数$\cdots$。</p><p>&emsp;&emsp;那么，怎么在代码中体现这中思维过程呢。我们用到的还是循环遍历，只是现在不再是对取到的每一个数进行二层循环的取余运算的素数判断。我们从已知的最小的素数2出发，在提前造出的一个覆盖计算范围的标记数组中将2的所有倍数点亮(当然1倍除外)，那么在下一层循环时，最先遇到的即为素数3，这时也将3的倍数点亮。重复以上操作，这就使得在外层的判断循环中，遇到的所有被点亮的数则自动略过，因为已经确认为合数。</p><p>&emsp;&emsp;这样的循环使得素数判断本身以及判断的规模缩小，达到缩减时间复杂度的效果。</p><p>代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N ...</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> notPrime[N];<span class="comment">//标记数组</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> isPrime[N];<span class="comment">//若有需要则作为存放素数的结果数组</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">EhrlichSieve</span><span class="params">()</span></span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">int</span> p=<span class="number">0</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">    <span class="built_in">memset</span>(notPrime,<span class="number">0</span>,N);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;N;++i)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">if</span>(!notPrime[i])&#123;<span class="comment">//若i为素数，此处的非值为true，执行以下步骤，若为合数则略过</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">            isPrime[p++]=i;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">2</span>*i;j&lt;N;j+=i)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">                notPrime[j]=<span class="number">1</span>;<span class="comment">//标记合数</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">return</span> p;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><hr><font size=10 color=66ccff>线性筛(Linear Sieve)</font><p>&emsp;&emsp;见识过埃氏筛后，你可能会发现，在埃氏筛的每一次标记合数的循环中，有些数被重复标记。</p><p>&emsp;&emsp;例如：6在2和3的倍数标记中均有出现。</p><p>&emsp;&emsp;显而易见，这种多余的操作也会在一定程度上占用时间复杂度，那么我们就有必要作出修改，规避重复标记。</p><p>&emsp;&emsp;实现的思想很简单，只是单纯在标记时加上必要的条件判断。</p><p>代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 100</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> notPrime[N];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> isPrime[N];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">EhrlichSieve</span><span class="params">()</span></span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">int</span> p=<span class="number">0</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">    <span class="built_in">memset</span>(notPrime,<span class="number">0</span>,N);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;N;++i)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">if</span>(!notPrime[i])</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">            isPrime[p++]=i;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;N;++j)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">if</span>(j*isPrime[j]&gt;=N)<span class="keyword">break</span>;<span class="comment">//保证在范围内操作</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">            notPrime[i*isPrime[j]]=<span class="number">1</span>;<span class="comment">//横向遍历并标记已得的素数的倍数，保证找到合数的依据是除1外的最小因数</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">if</span>(i%isPrime[j]==<span class="number">0</span>)<span class="keyword">break</span>;<span class="comment">//若此时遍历到的数的因数已经存在，则表明已经标记过了，跳出循环</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">return</span> p;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="Algorithm" scheme="http://yoursite.com/categories/Algorithm/"/>
    
    
  </entry>
  
  <entry>
    <title>QuikPower</title>
    <link href="http://yoursite.com/2019/12/07/QuikPower/"/>
    <id>http://yoursite.com/2019/12/07/QuikPower/</id>
    <published>2019-12-07T05:00:27.000Z</published>
    <updated>2020-04-11T03:34:17.745Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><hr></p><p><head><font size=15 color=66ccff><strong>快速幂</strong></font><meta name="generator" content="Hexo 4.0.0"><link rel="alternate" href="/atom.xml" title="Niemand" type="application/atom+xml"></head></p><p><hr></p><p>&emsp;&emsp;在一般的幂运算中，给定底数x和质数n，若使用循环，在每次循环中给积变量乘上一个x，总共需要乘n个x，也就是时间复杂度为o(n)。</p><p>&emsp;&emsp;但是这样的时间复杂度还是不能满足需求，而快速幂就可以优化加速这样的运算。</p><p>&emsp;&emsp;先来分析指数n，我们都知道在计算机中数字都是二进制存储，也就是二进制可以表示所有数，而二进制数每一位只有两种状态，0和1。那么指数n也就可以表示成二进制数，如下：</p><script type="math/tex; mode=display">n=2^{p_1}+2^{p_2}+2^{p_3}+\cdots+2^{p_n}</script><p><p>&emsp;&emsp;这样之后，完整的幂运算也就可以表示成：</p></p><script type="math/tex; mode=display">ans=x^{2^{p_1}+2^{p_2}+\cdots+2^{p_n}}=x^{2^{p_1}}*x^{2^{p_2}}*\cdots*x^{2^{p_n}}</script><p>&emsp;&emsp;那么如何做到代码实现呢？我们想到$ans$若初值为1，那么我们同样在循环中给$ans$乘上一个值，在循环结束后便能得到答案，而这个乘数就是迭代器$i$控制下的$x^{2^{p_i}}$。虽然和原始做法一样都用了循环，但在快速幂中循环的次数是根据$n$的二进制数的位数而定的,也就是$log_2{n}$，而时间复杂度也自然就是$o(log{n})$级。</p><p>代码实现如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">qpo</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> n)</span></span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">int</span> temp=<span class="number">2</span>,ans=<span class="number">1</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">while</span>(n)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">if</span>(n&amp;<span class="number">1</span>)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">            ans*=temp;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">        temp*=temp;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">        n&gt;&gt;=<span class="number">1</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">return</span> ans;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="Algorithm" scheme="http://yoursite.com/categories/Algorithm/"/>
    
    
      <category term="Algorithm" scheme="http://yoursite.com/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>Data Structure</title>
    <link href="http://yoursite.com/2019/12/03/Data-Structure/"/>
    <id>http://yoursite.com/2019/12/03/Data-Structure/</id>
    <published>2019-12-03T15:10:57.000Z</published>
    <updated>2019-12-07T16:09:49.928Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><head><font size=12 color=66ccff>Stack</font><meta name="generator" content="Hexo 4.0.0"><link rel="alternate" href="/atom.xml" title="Niemand" type="application/atom+xml"></head></p><p><hr></p><p><head><strong><font szie=10 color=purple>栈(stack)</font></strong></head><br><strong>c/cpp实现</strong><br></p><pre><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stack</span>&#123;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">int</span> member;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stack</span> *<span class="title">next</span>;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">top</span><span class="params">(<span class="built_in">stack</span> *head)</span></span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">return</span> head-&gt;member;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">(<span class="built_in">stack</span> *p)</span></span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">    p-&gt;next=p-&gt;next-&gt;next;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> n,<span class="built_in">stack</span> *p,<span class="built_in">stack</span> *head)</span></span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">    p-&gt;member=n;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">    p-&gt;next=head-&gt;next;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">    head-&gt;next=p;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">(<span class="built_in">stack</span> *head)</span></span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">25</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">return</span> head-&gt;member==<span class="literal">NULL</span>?<span class="literal">false</span>:<span class="literal">true</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">26</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">27</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">28</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">29</span></pre></td><td class="code"><pre><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stack</span> *<span class="title">head</span>;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">30</span></pre></td><td class="code"><pre><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stack</span> *<span class="title">p</span>=(<span class="title">struct</span> <span class="title">stack</span>*)<span class="title">malloc</span>(<span class="title">sizeof</span>(<span class="title">struct</span> <span class="title">stack</span>));</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">31</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="Data Structure" scheme="http://yoursite.com/categories/Data-Structure/"/>
    
    
  </entry>
  
  <entry>
    <title>Sorting Algorithm</title>
    <link href="http://yoursite.com/2019/11/29/Sorting-Algorithm/"/>
    <id>http://yoursite.com/2019/11/29/Sorting-Algorithm/</id>
    <published>2019-11-29T08:42:45.000Z</published>
    <updated>2019-12-13T13:47:18.868Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script>    <div id="aplayer-elkBEGoc" class="aplayer aplayer-tag-marker meting-tag-marker"         data-id="3096834640" data-server="netease" data-type="playlist" data-mode="circulation" data-autoplay="false" data-mutex="true" data-listmaxheight="340px" data-preload="auto" data-theme="#555"    ></div><p><hr></p><p><head><font size=15 color=#66ccff>Sorting Algorithem(updating)</font><meta name="generator" content="Hexo 4.0.0"><link rel="alternate" href="/atom.xml" title="Niemand" type="application/atom+xml"></head></p><p><hr></p><p><head><strong>冒泡排序(Bubble Sort)</strong></head></p><p>&emsp;&emsp;冒泡排序正如其名，是让乱序的数像泡泡一样一个接一个“冒上来”。</p><p>&emsp;&emsp;该方法设置两层循环（时间复杂度为O(n^2))，外层循环进行(n-1)次迭代，指冒出(n-1)次气泡；内层循环则是一次冒泡的过程。</p><strong>代码如下：</strong><br><pre>//从小到大排序#include&lt;bits/stdc++.h&gt;using namespace std;int a[N];//N为数组长度常量int main(){    int temp;    for(int i=0;i&lt;N-1；i++){        for(int j=0;j&lt;N-1;j++){            if(a[j]&gt;a[j+1]){                temp = a[j];                a[j] = a[j+1];                a[j+1] = temp;            }//若左边的数大于有边的数则交换两数，将更大的数不断右移        }    }    return 0;}</pre><hr><font color=pink>Next</font><hr><head><strong>快速排序(Quicksort)</strong></head><p>&emsp;&emsp;快速排序是利用递归的一种排序。</p><p>&emsp;&emsp;首先在一组数列中取一个key值(将它赋值给一个temp，因为这个值本身也要参加排序，我自己写的时候犯蠢了，让这个值固定不动了)，然后在数列左右两边分别向中间遍历，并在必要时进行交换，使得比key值小的数都在左边，比key值大的数都在右边，而两边交汇处则正是key值应该在的地方，而由于在下面的代码中，会控制<font color=red>原key值位置不变</font>(即开头)，这时将key值插入(与交汇位置的值交换)。</p><p>&emsp;&emsp;这一通操作后,key值得绝对位置确定了。而key值两边的值还是乱序的，那么两边现在其实就可以看作两个缩短版的原数列，分别采取同上的操作(即递归中的调用函数本身)，然后不断确定新的key值，而每确定一个，就会在其两边产生更短的乱序数列，知道产生的乱序数列只有一个值的时候，则没有必要再排，递归完成。</p><hr><strong>代码如下：</strong><pre>#include&lt;bits/stdc++.h>int a[N]={....};//使用全局变量可以方便不同函数调用void quickSort(int left,int right ) {    int i, j,temp,t;    i = left;    j = right;    temp = a[left];    if (left &gt;= right)return;    while (i != j) {        //这两处while循环的"="使得与key值相等的数位置不变        while (a[j] &gt;= temp&&i&lt;j)            j- -;        while (a[i] &lt;= temp&&i&lt;j)            i++;        if (i &lt;= j) {            t = a[i];            a[i] = a[j];            a[j] = t;        }    }    a[left] = a[i];    a[i] = temp;    //将下一轮排序的首位值传入，在全局数组中确定位置    quickSort(left, i - 1);    quickSort(i + 1, right);}</pre><hr><font color=pink>next</font><hr><head><strong>桶排序(Bucket Sort)、基数排序(Radix Sort)</strong></head><p>&emsp;&emsp;桶排序这个名字是个很形象的描述，就是先确定几个用来装数据的“桶”，而这些“桶”管理不同的数据范围，也就是将待排序的一组乱序数据根据自身的大小放入不同的“桶”中，而这些已经表明范围的“桶”已经拥有一定的顺序，或者说确定和分配范围的过程就是一种预排序。这些被大致划分并排序的一组组数据内部在进行排序就可以再重新输出时得到完整排序的数列了。</p><p>&emsp;&emsp;在选择“桶”的范围时，我们往往会选择能使数据均匀分布的划分方式。而对于基数排序，他的排序思想和桶排序基本相同，区别就在于基数排序在造“桶”时会选择常用的进制数，如10、2、16等，而这也就使得这种排序更加适用于数据更加集中的乱序数列的排序中。</p><p>&emsp;&emsp;在下面的例子中将展示以10为划分范围的基数排序，其实也同样展现了桶排序的实现方法。</p><pre>#include<iostream>#include<stack>(#include&lt;bits/stdc++.h>)#define N ...using namespace std;int a[N]={...};//由于这里以10为范围，数组中的数应尽量集中//c/cpp中桶的实现可以用结构体来进行struct bucket{    stack<int> pos;    struct bucket *next;}bucket;void BucketSort(){    struct bucket *p;    int temp;    for(int i=0;i&lt;N;++i){        //下面将每个数对应各自的“桶”，以10为划分范围        for(int j=0;j<(a[i]/10);++j){            p=p->next;        }        //在找到对应的桶后，与之前的数进行比较，保证各个“桶”内也按序排列<br>        (但这里的内部排序实现可能这里写得比较复杂，你可以用你自己觉得ok的方法)        while(p->pos.top()==NULL||p->pos.top()<=a[i])            p->pos.push(temp);        while(p->pos.top()>a[i]){            p->temp.push(p->pos.top());            p->pos.pop();        }        p->pos.push(a[i]);        while(p->temp.top()!=NULL){            p->pos.push(p->temp.top());            p->temp.pop();        }    }}int main(){...//函数调用}</pre><hr><font color=pink>next</font><hr><head><strong>哈希排序(Hash Sort)</strong></head><p>&emsp;&emsp;哈希排序我认为可以算是一种特殊的桶排序，一种划分范围是1的桶排序。</p><p>&emsp;&emsp;也正因如此，哈希排序免除了桶内排序的操作，思想上也更为直接，但同时这种方法肯定是不稳定的，而且是一种牺牲空间换时间的方法。但在某些对空间要求并不苛刻的情况下，哈希不失为一种好的排序选择。(哈希虽然可耻，但是有效)</p><pre>#include<iostrem>#define N 10using namespace std;int a[N]={};void HashSort(){    int p[100];//创建一个包含待排数列中所有数范围的数组    for(int i=0;i&lt;N;++i){//在数列中有的数对应的位置做标记        p[a[i]]++;    }}int main(){...//调用函数}</pre><hr><font color=pink>next</font><hr><head><strong>直接插入排序(Insertion Sort)</strong></head><p>&emsp;&emsp;插入排序就是在乱序数列中(最左)先取一个初始数，因为只有一个数，所以认为已经排好序(此处以自小至大为例)，而从剩下的依旧乱序的数列依次取出一个在已经排好序的做数列中找到相应的位置，再插入。(就是一般被大家比作理扑克那个)</p><pre>#include<iostream>#define N ...using namespace std;int a[N]={...};void InsertionSort(){    int i,j;    int temp;    for(i=1;i&lt;N;++i){        if(a[i]&lt;a[i-1]){        //若右边的数已经大于左边最后一个数则无需插入            temp=a[i];            for(j=i-1;j&gt;=0&&a[j]&gt;temp;j--){                    a[j+1]=a[j];            }            a[j+1]=temp;        }    }}int main(){...//调用函数}</pre><head><strong>分组插入排序(Grouping Insertion Sort)</strong></head><p>&emsp;&emsp;</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="Algorithm" scheme="http://yoursite.com/categories/Algorithm/"/>
    
    
      <category term="Sorting" scheme="http://yoursite.com/tags/Sorting/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://yoursite.com/2019/11/28/hello-world/"/>
    <id>http://yoursite.com/2019/11/28/hello-world/</id>
    <published>2019-11-27T23:38:36.059Z</published>
    <updated>2019-11-27T23:38:36.059Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">$ hexo server</span></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">$ hexo generate</span></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Arrival of the General</title>
    <link href="http://yoursite.com/2019/11/28/Arrival-of-the-General/"/>
    <id>http://yoursite.com/2019/11/28/Arrival-of-the-General/</id>
    <published>2019-11-27T16:00:00.000Z</published>
    <updated>2019-11-28T17:05:58.400Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script>    <div id="aplayer-JdJdFHWo" class="aplayer aplayer-tag-marker meting-tag-marker"         data-id="1371262339" data-server="netease" data-type="song" data-mode="circulation" data-autoplay="false" data-mutex="true" data-listmaxheight="340px" data-preload="auto" data-theme="#555"    ></div><h1 id="CodeForces-144A"><a href="#CodeForces-144A" class="headerlink" title="CodeForces 144A"></a><strong>CodeForces 144A</strong></h1><h2 id="Arrival-of-the-General"><a href="#Arrival-of-the-General" class="headerlink" title="Arrival of the General"></a>Arrival of the General</h2><p><p1>&emsp;A Ministry for Defense sent a general to inspect the Super Secret Military Squad under the command of the Colonel SuperDuper. Having learned the news, the colonel ordered to all n squad soldiers to line up on the parade ground.</p1><br></p><p><p2>&emsp;By the military charter the soldiers should stand in the order of non-increasing of their height. But as there’s virtually no time to do that, the soldiers lined up in the arbitrary order. However, the general is rather short-sighted and he thinks that the soldiers lined up correctly if the first soldier in the line has the maximum height and the last soldier has the minimum height. Please note that the way other solders are positioned does not matter, including the case when there are several soldiers whose height is maximum or minimum. Only the heights of the first and the last soldier are important.</p2><br></p><p><p3>&emsp;For example, the general considers the sequence of heights (4, 3, 4, 2, 1, 1) correct and the sequence (4, 3, 1, 2, 2) wrong.</p3><br></p><p4>&emsp;Within one second the colonel can swap any two neighboring soldiers. Help him count the minimum time needed to form a line-up which the general will consider correct.</p4><p><strong>Input</strong></p><p>&emsp;The first input line contains the only integer n (2 ≤ n ≤ 100) which represents the number of soldiers in the line. The second line contains integers a1, a2, …, an (1 ≤ ai ≤ 100) the values of the soldiers’ heights in the order of soldiers’ heights’ increasing in the order from the beginning of the line to its end. The numbers are space-separated. Numbers a1, a2, …, an are not necessarily different.</p><p><strong>Output</strong></p><p><p>&emsp;Print the only integer — the minimum number of seconds the colonel will need to form a line-up the general will like.</p></p><hr><p><strong>Example</strong><br><br><br>input<br></p><p><pre>433 44 11 22</pre><br><br>output<br></p><p><pre>2</pre><br><br>input<br></p><p><pre>710 10 58 31 63 40 76</pre><br><br>output<br></p><p><pre>10</pre></p><hr><p><strong>代码如下（AC）：</strong><br></p><p><pre></p><h1 id="include”pch-h”"><a href="#include”pch-h”" class="headerlink" title="include”pch.h”"></a>include”pch.h”</h1><h1 id="include"><a href="#include" class="headerlink" title="include"></a>include<iostream></h1><pre><code>gen</code></pre><p>using namespace std;</p><p>int main() {<br>    int n;<br>    int s[101];<br>    int p1=0, p2=0;<br>    int max, min;<br>    cin &gt;&gt; n;<br>    cin &gt;&gt; s[0];<br>    max = s[0];<br>    min = s[0];<br>    for (int i = 1; i&lt; n; i++) {<br>        cin &gt;&gt; s[i];<br>        if (max &lt; s[i]) {<br>            max = s[i];<br>            p1 = i;<br>        }<br>        if (min &gt;= s[i]) {<br>            min = s[i];<br>            p2 = i;<br>        }<br>    }<br>    if (p1 &lt; p2)<br>        cout &lt;&lt; p1 + n - 1 - p2 &lt;&lt; endl;<br>    else<br>        cout &lt;&lt; p1 + n - 2 - p2 &lt;&lt; endl;<br>    return 0;<br>}<br>&lt;/pre&gt;</p><hr><p><strong>解题思路：</strong><br></p><p><p1>&emsp;&emsp;首先，题面确定了最左边的最高的，最右边的是最低的，而在队列中间的顺序不予考虑。那么，先对情境做一个转换，即在一组乱序数列中，寻找一个最大值移至首位，一个最小值移至末尾，并得到最小移动步数。</p1><br></p><p><p2>&emsp;&emsp;数字在数组中的移动可以通过迭代实现，但如何得到最小步数呢？这时就需要考虑到最小值或最大值出现多次的情况，这可能影响你选择作为移动的那个数。但我们已经事先知道最大值要去最左边，最小值要去最右边，那么需要被移动的最大值对应的下标应该尽量小（因为使用数组时，用下标大小模拟左右），相反的最小值的下标应该尽量大。</p2><br></p><p><p3>&emsp;&emsp;再来看看如何取得所需的下标。最大值和最小值的初始值均取<code>s[0]</code>，即位于最左端，那么对于变量max来说，如果之后遇到相等的值，将保留现有下标；对于变量min来说，遇到相等的值应该获取更大的下标。</p3><br></p><p><p4>&emsp;&emsp;取得各自的下标后，若最大值下标在左，则只需将移动步数相加即可；若最大值下标在右，则需考虑两值交换只算一步，总数需减一。</p4></p><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="Exercises" scheme="http://yoursite.com/categories/Exercises/"/>
    
    
      <category term="Threshold" scheme="http://yoursite.com/tags/Threshold/"/>
    
  </entry>
  
  <entry>
    <title>Simple Mathematical Optimization</title>
    <link href="http://yoursite.com/2019/11/28/Simple-Mathematical-Optimization/"/>
    <id>http://yoursite.com/2019/11/28/Simple-Mathematical-Optimization/</id>
    <published>2019-11-27T16:00:00.000Z</published>
    <updated>2019-11-28T17:16:06.746Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script>    <div id="aplayer-znbARtsd" class="aplayer aplayer-tag-marker meting-tag-marker"         data-id="1371262339" data-server="netease" data-type="song" data-mode="circulation" data-autoplay="false" data-mutex="true" data-listmaxheight="340px" data-preload="auto" data-theme="#555"    ></div><h1 id="Simple-Mathematical-Optimization"><a href="#Simple-Mathematical-Optimization" class="headerlink" title="Simple Mathematical Optimization"></a><strong>Simple Mathematical Optimization</strong></h1><p><hr></p><head><strong>CodeForces 451A</strong><meta name="generator" content="Hexo 4.0.0"><link rel="alternate" href="/atom.xml" title="Niemand" type="application/atom+xml"></head><p><p1>&emsp;After winning gold and silver in IOI 2014, Akshat and Malvika want to have some fun. Now they are playing a game on a grid made of n horizontal and m vertical sticks.&lt;/p2&gt;<br></p><p><p2>&emsp;An intersection point is any point on the grid which is formed by the intersection of one horizontal stick and one vertical stick.</p2><br></p><p><p3>&amp;emspIn the grid shown below, n = 3 and m = 3. There are n + m = 6 sticks in total (horizontal sticks are shown in red and vertical sticks are shown in green). There are n·m = 9 intersection points, numbered from 1 to 9.</p3><br></p><p><p4>&emsp;The rules of the game are very simple. The players move in turns. Akshat won gold, so he makes the first move. During his/her move, a player must choose any remaining intersection point and remove from the grid all sticks which pass through this point. A player will lose the game if he/she cannot make a move (i.e. there are no intersection points remaining on the grid at his/her move).</p4><br></p><p><p5>&emsp;Assume that both players play optimally. Who will win the game?</p5><br></p><hr><p><strong>Input</strong></p><p><p>&emsp;The first line of input contains two space-separated integers, n and m (1 ≤ n, m ≤ 100).</p><br><strong>Output</strong></p><p><p>&emsp;Print a single line containing “Akshat” or “Malvika” (without the quotes), depending on the winner of the game.</p></p><hr><p><strong>Examples</strong><br><br><br>Input</p><pre>2 2</pre>Output<pre>Malvika</pre>Input<pre>2 3</pre>Output<pre>Malvika</pre>Input<pre>3 3</pre>Output<pre>Akshat</pre><strong>Note</strong><br>Explanation of the first sample:<br><p1>&emsp;The grid has four intersection points, numbered from 1 to 4.</p1><br><p2>&emsp;If Akshat chooses intersection point 1, then he will remove two sticks (1 - 2 and 1 - 3). The resulting grid will look like this.</p2><br><p3>&emsp;Now there is only one remaining intersection point (i.e. 4). Malvika must choose it and remove both remaining sticks. After her move the grid will be empty.</p3><br><p4>&emsp;In the empty grid, Akshat cannot make any move, hence he will lose.</p4><br><p5>&emsp;Since all 4 intersection points of the grid are equivalent, Akshat will lose no matter which one he picks.</p5><hr><strong>代码如下（AC）：</strong><pre>#include<iostream>using namespace std;int main(){    int x,y,t;    cin>>x>>y;    t=x<y?x:y;    if(t%2==0)        cout<<"Malvika";    else        cout<<"Akshat";    return 0;}</pre><hr><strong>解题思路：</strong><br><p1>&emsp;&emsp;题目的意思是两个人，一次选择一个点，拿走构成该点的两根棒，拿走最后两根的人获胜。</p1><br><p2>&emsp;&emsp;如果考虑模拟的做法，那么可能需要一个二维数组进行循环操作。但是这里需要优先在程序外考虑。假设这个矩阵有x条纵轴，y条横轴。首先由Akshat拿走一根纵轴和一根横轴，那么到了Malvika则剩余(x-1)条纵轴和(y-1)条横轴，重复前者的操作。当没有能选择的点则游戏结束，即横轴或纵轴有一边或两边为0。也就是说当横轴和纵轴里较少的一个被拿完则下一个轮到的为输家。</p2><br><p3>&emsp;&emsp;就结论来看，谁是赢家取决于x和y中那个较小的数是奇是偶。</p3><br><br><hr><head><strong>CodeForces 460A</strong></head><p1>&emsp;Vasya has n pairs of socks. In the morning of each day Vasya has to put on a pair of socks before he goes to school. When he comes home in the evening, Vasya takes off the used socks and throws them away. Every m-th day (at days with numbers m, 2m, 3m, …) mom buys a pair of socks to Vasya.</p1><br> <p2>&emsp;She does it late in the evening, so that Vasya cannot put on a new pair of socks before the next day. How many consecutive days pass until Vasya runs out of socks?</p2><br><hr><strong>Input</strong><br><p>&emsp;The single line contains two integers n and m (1 ≤ n ≤ 100; 2 ≤ m ≤ 100), separated by a space.</p><br><strong>Output</strong><br><p>Print a single integer — the answer to the problem.</p><br><hr><strong>Examples</strong><br><br>Input<pre>2 2</pre>Output<pre>3</pre>Input<pre>9 3</pre>Output<pre>13</pre><p><strong>Note</strong><br></p><p><p1>&emsp;In the first sample Vasya spends the first two days wearing the socks that he had initially. Then on day three he puts on the socks that were bought on day two.</p1><br></p><p><p2>&emsp;In the second sample Vasya spends the first nine days wearing the socks that he had initially. Then he spends three days wearing the socks that were bought on the third, sixth and ninth days. Than he spends another day wearing the socks that were bought on the twelfth day.</p2></p><p><hr><br><strong>代码如下(AC)：</strong></p><p><pre>#include<iostream></p><p>using namespace std;</p><p>int main() {<br>    int n, m;<br>    int d;<br>    cin &gt;&gt; n &gt;&gt; m;<br>    d = n * m / (m - 1);<br>    if (d%m == 0)<br>        d—;<br>    cout &lt;&lt; d &lt;&lt; endl;<br>    return 0;<br>}&lt;/pre&gt;</p><p><hr><br><strong>解题思路：</strong><br></p><p><p1>&emsp;&emsp;首先这题一般采取的是进行循环，至n≤m时停止循环，因为此时在袜子穿完前不会再只能加了。</p1><br></p><p><p2>&emsp;&emsp;而这种操作虽然已经很简洁了，但依然O(n)的复杂度。那么，在编写程序前，先根据题面列出等式,并化简得：d=(n*m)/(m-1)。其中d至天数，而很快就会发现exanple中的第一对输入输出就不满足了，那么再脑内模拟一下就会发现在求得的d能整除m时d应该减一。因为在这种情况意味着在新袜子到的前一天刚好穿完了袜子，而新的袜子不能在第一天被穿。</p2><br></p><p><p3>&emsp;&emsp;此时的程序要操作的主要步骤只有一条计算式和一个条件判断，复杂度为O(1)级。(虽然这优化可能没什么用，但这种思想可以应用到别的更复杂的题目中（如：约瑟夫环）。)</p3></p><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="Exercises" scheme="http://yoursite.com/categories/Exercises/"/>
    
    
      <category term="Threshold" scheme="http://yoursite.com/tags/Threshold/"/>
    
  </entry>
  
</feed>
